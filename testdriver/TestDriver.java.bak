/*
 *
 * IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18
 *
 * (C) COPYRIGHT IBM CORP. 2006,2014
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 *
 */

/**
 * 	The driver will take a previously recorded JSON test bin file and step thru it, executing
 * 	each "event".
 * 
 * The properties in TpaeTestFramework.properties will
 * control execution of the bin files - when files get run, against what URL, etc.
 * 
 * After those properties are defined you can simply run the TpaeTestDriver or
 * and it will execute the bin file(s). A test file has contents similar to:
 * 
 * { 
 * 		"configuration": {
 * 			"startApp":"wotrack",
 * 			"keywords":["unicorn", "ui", "wotrack"],
 * 			"dataInputFile":  "./tests/testcases/RecordedExamples/WorkOrderInput.data",
 * 			"dataOutputFile": "./tests/testcases/RecordedExamples/WorkOrderGenerated.data"
 * 		},
 * 
 * 
 * 		"interactions" : [
 * 			{"event":"gotoApp", "app":"wotrack"},
 *			{"event":"click","id":"m72b67f92-tb",
 *			{"event":"typeover","id":"m72b67f92-tb","params":["something"]},
 *			{"event":"screenshot"},
 *			{"event":"sleep","params":[2]},
 *			{"event":"assertAttributeTrue","id":"m6a7dfd2f_tfrow_[C:1]_txt-tb","attribute":"attributeName",  "value":"some value"},
 *			{"event":"keystroke","id":"m6a7dfd2f_tfrow_[C:3]_txt-tb","params":[9,"\t",false,false,true],
 *			{"event":"callout",
 *				"binfile":"callout.bin", 
 *				"params":"$ARG_NUM_1, null, true, $ARG_NUM_2, false, $DUMMY",
 *				"dataInputFile": "./tests/testcases/RecordedExamples/CalloutInput.data",
 *				"dataOutputFile": "./tests/testcases/RecordedExamples/CalloutGenerated.data"},
 * 		]
 * }
 * 
 */

//	To run from the command line:
//
//	Copy testng_customsuite from Eclipse to c:\temp 
//	(e.g. C:\Users\IBM_AD~1\AppData\Local\Temp\testng-eclipse-812311290\testng-customsuite.xml)
//
//	Copy testng.jar from Eclipse to c:\temp
//	(e.g. C:/Mobile-Next-2/eclipse/plugins/org.testng.eclipse_6.8.6.20141201_2240/lib/testng.jar)
//
//	Then do something like this, where C:\src\MobileNext-Rel-2\Automation is the root
//	directory of my project:
//
//	set PROJROOT=C:\src\MobileNext-Rel-2\Automation
//	java -Djava.net.preferIPv4Stack=true -ea -Dfile.encoding=Cp1252 -classpath C:/temp/testng.jar;%PROJROOT%\classes;%PROJROOT%\lib\* org.testng.TestNG C:\temp\testng-customsuite.xml
//	

package tests.testdriver;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.EmptyStackException;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.Vector;

import org.apache.commons.json.JSONArray;
import org.apache.commons.json.JSONException;
import org.apache.commons.json.JSONObject;
import org.openqa.selenium.By;
import org.openqa.selenium.Dimension;
import org.openqa.selenium.Point;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.ui.Select;
import org.testng.ITestResult;
import org.testng.annotations.Factory;
import org.testng.annotations.Test;

import framework.AutomationBaseTest;
import framework.AutomationUtility;
import framework.DateUtil;
import framework.Logger;
import framework.TestTask;
import framework.listeners.report.CustomReporter;
import framework.selenium.Browser;
import framework.selenium.TpaeBrowser;


/**
 * Test Driver - will execute bin files generated by the recorder. Extended by TpaeTestDriver
 */
public class TestDriver extends AutomationBaseTest {

	// *************************************************************************************
	// Start: Automation Framework Boilerplate stuff

	// A useful description of the test case and what it does.
	public static String description = "Test driver for running previously recorded tests";

	// If there is a manual test case that this is based on indicate it here for reference.
	public static String reference_testcase = null;

	// Helpful keywords to say what this test case does and when it should be
	// run. Same as what will be set in the @Test group annotation
	public static String[] keywords = { "Driver", "JSON" };

	// Where there any issues that this test case covers?
	public static String[] related_issues = null;

	// Indicate any applications this test case makes use of here.
	public static String[] applications = { "Test Driver" };

	// End: Automation Framework Boilerplate stuff
	// *************************************************************************************

	// Private static variables

	// Log message colors

	public static final String JSON_TEXT_COLOR = "#0000ff"; 	// blue - for displaying JSON elements
	// (configuration/interactions)
	private static final String SUCCESS_COLOR = "#008000"; 		// green - for displaying test/callout successful message
	private static final String CALLOUT_START_COLOR = "#008000"; // green - for displaying callout start message
	private static final String SEVERE_COLOR = "#ff0000"; 		// red - for test failures or severe messages
	private static final String CALLOUT_COLOR = "#ff6633"; 		// orange - for callout looping
	private static final String COMMENT_COLOR = "#cc00ff"; 		// purple - for comments
	private static final String ELAPSED_TIME_COLOR = "#006666"; // green-ish - for showing elapsed time of an event/interaction

	//	Misc constants

	private static final String INDENT = "&nbsp;&nbsp;&nbsp;&nbsp;";

	// Global variables

	private Class<Browser> browserClass = null;	//	our current Browser class (tpae)
	private int totalBrowserInstances = 0;		//	total browser instances on the screen (1-based)
	private int currentBrowserInstance = 0;		//	the currently maximized browser instance index (1-based)
	private Browser browserInstance[] = new Browser[MAX_DRIVERS + 1]; 		// array of browser instances (1-based, 0 is empty)
	private boolean loggedInForInstance[] = new boolean[MAX_DRIVERS + 1]; 	// array of logged in info (1-based, 0 is empty)
	private static String curAppForInstance[] = new String[MAX_DRIVERS + 1];// array of current apps (1-based, 0 is empty)

	private Dimension defaultWindowSize = null;	//	the size of the browser instance created by Selenium
	private Point defaultWindowPosition = null;	//	the default screen position for the browser instance created by Selenium

	private Search searchObject = null; // our search object (e.g. KeywordSearch, PropsFileSearch)


	private String generatePerfReport = "false"; 	// from uitest.generate.perf.report in the Framework.properties file
	private PerformanceDriver performanceDriver = null; // the performance metrics collection driver

	private String uitestRootFolder = null; 		// from uitest.root.folder in the Framework.properties file

	private int retries = 0; 	// How many test retries to make for a failing test.
	// (can be set in configuration section of bin file - "retry" attribute)
	private int globalRetries = -1;	// How many test retries to make for a failing test.
	// From uitest.retryCount in the props file.
	// This overrides "retry" attribute specified in the test file configuration section
	private String stopOnFirstFailure = "false"; // From uitest.stop.on.first.failure in the props file
	private String logEventElapsedTime = "false"; // from uitest.log.event.elapsedTime in the props file
	private String takeScreenshots = "false"; // from uitest.takeScreenshots in the props file
	private static String INPUT_FILE_BASE_NAME_PROPERTY = "dataInputFile";

	// The following variables only apply when the test data input file has a  "lastStep"
	// specified, so we can pick up where we left off.

	private String currentStep = null; 			// the current test step we're working on
	private String lastSuccessfulStep = null; 	// the last test step we successfully executed
	private String startingStep = "None"; 		// either "None" or the lastStep defined in the current data input file
	private String ignoreLastStep = "false";	// do we ignore the lastStep defined in the data input file
	// From uitest.ignore.laststep in the props file

	private Stack<Integer> currentInteraction = null; 	// The current interaction we are working on in a bin file.
	// Manipulated by "for" and "while" loops.

	private boolean breakpointWasCalled = false; //if the BREAKPOINT method/event was called or not

	private boolean weAreInBVTSetup = false;	// Are we running BVTSetup? 

	private String winHandleBefore = null;      // original browser instance
	
	private String loopCntr = null; // for and while loop counter
	
	private String dataOutputFile = null;
	
	ArrayList<Hashtable<String, String>> outputDataArrayList = new ArrayList<Hashtable<String, String>>();
	
	boolean dataFileWasAppended = false;
	
	boolean breakLoop = false;
	
	String calloutReturnValue = null;
	
	private String defaultURL = null;

	// Constructor used by whoever extends TestDriver (e.g. TpaeTestDriver)
	public TestDriver(String configFile, String browser) {
		super(configFile, browser);
	}

	// Constructor used when running TestDriver by itself - can be removed
	@Factory(dataProvider = "browsers")
	public TestDriver(String browser) {
		super(browser);
	}

	/**
	 * This is our Test Driver main entry point.
	 * 
	 * @throws IOException
	 */

	@Test(groups = { "test driver", })
	public void Driver() {

		Logger.detailsFine("TestDriver.Driver()");

		String binFilePath = null; 	// the full path to the current test bin file to execute
		TestTask testTask = null; 	// the TestTask object for the bin file test (just for logging purposes)
		int testsAttempted = 0; 	// the total number of tests run (just for logging purposes)
		Browser browser = null;

		Iterator<String> keyset = null;	//	the list of bin files to execute

		/**
		 * Start - do any test driver initialization
		 */
				
		setTotalBrowserInstances(1);
		setCurrentBrowserIndex(1);
		browser = getBrowser(); // special case for first browser instance,  otherwise use getBrowser(totalBrowserInstances)
		browserClass = (Class<Browser>) browser.getClass(); // TpaeBrowser
		setBrowserInstance(getCurrentBrowserIndex(), browser);
		setLoggedInForInstance(getCurrentBrowserIndex(), false);
		defaultWindowSize = browser.getDriver().manage().window().getSize();
		defaultWindowPosition = browser.getDriver().manage().window().getPosition();

		//	Initialize our HTML result log

		CustomReporter.setupTestDriverMode();
		
		// Search for keyword search parameter:
		// 		-Dkeywords=keyword1,keyword2,etc.
		// It can only be passed in as a VM command line argument - there is no
		// props file entry for it.

		String testKeywords = System.getProperty("keywords");

		// Override properties file properties with command line args if need be.
		// That way they have the right values before we log in.

		processAnyCommandLineArgs();

		// Go find the appropriate bin files to run - either from the
		// TestFramework.properties file or from the "keywords" search parameter.

		uitestRootFolder = AutomationUtility.getProperty("uitest.root.folder");
		testTask = Logger.startTestTask("Find the bin file(s) ...");

		try {

			if (uitestRootFolder != null && testKeywords != null) {

				// This must be a keyword search

				Logger.logInfo("Keywords: "	+ (testKeywords == null ? "<none>" : testKeywords));
				Logger.logInfo("Test root path: " + uitestRootFolder);
				searchObject = new KeyWordSearch(testTask, testKeywords, uitestRootFolder);
			} else if (testKeywords != null) {

				// If a root folder path is not specified, but keywords are ..
				// we don't have enough information for a keyword search. Just terminate.

				Utils.logSevere("ERROR: Keywords specified but the \"-Duitest.root.folder=\"  property is missing from the command line arguments");
				testTask.setStatus(ITestResult.FAILURE);
				Logger.startTestTask("Do not report");
				browser.driverFail("Test Execution Failed");	// forces the HTML log to show an overall failure
			} else {
				// Else, this must be a TestFramework.propeties search, not a keyword search.

				// Use the uitest.root.folder as the default root folder to look
				// under or else use the current project root folder.

				if (uitestRootFolder == null || uitestRootFolder.trim().equals("")) {
					try {
						uitestRootFolder = new File(".").getCanonicalPath();
					} catch (IOException ioe) {
						Utils.logSevere("ERROR: Could not find root path for uitest");
						testTask.setStatus(ITestResult.FAILURE);
						Logger.startTestTask("Do not report");
						browser.driverFail("Test Execution Failed");	// forces the HTML log to show an overall failure
					}
				}
				searchObject = new PropsFileSearch(uitestRootFolder, testTask);
			}
		} catch (SQLException e) {
			testTask.setStatus(ITestResult.FAILURE);
			Utils.logSevere("ERROR: SQL error retrieving FEATURETOGGLE from MAXVARS table");
			Utils.processStackTrace(e);
			testTask.setStatus(ITestResult.FAILURE);
			Logger.startTestTask("Do not report");
			browser.driverFail("Test Execution Failed");	// forces the HTML log to show an overall failure
		} 

		//	If an error occurred trying to do the search, set the test result status to failure.

		if(searchObject.errorHappened()) {
			testTask.setStatus(ITestResult.FAILURE);
		}

		// Get the list of bin files we found - might be empty

		keyset = searchObject.getFileList();

		//	Read any global properties that control test execution

		// For the performance team. Whether or not to generate a performance
		// report after each test execution.

		generatePerfReport = AutomationUtility.getProperty("uitest.generate.perf.report", "false");

		//	Do we stop ALL testing on first test failure?

		stopOnFirstFailure = AutomationUtility.getProperty("uitest.stop.on.first.failure", "false");

		//	Do we ignore the lastStep defined in the input data file?

		ignoreLastStep = AutomationUtility.getProperty("uitest.ignore.laststep", "false");

		//	Do we log the elapsed time if UI events?

		logEventElapsedTime = AutomationUtility.getProperty("uitest.log.event.elapsedTime", "false");

		//  Do we take screenshots during a test run (using the screenshot event)?

		takeScreenshots = AutomationUtility.getProperty("uitest.takeScreenshots","false");

		//	Do we override the "retry" count in the test configuration section with the global retry count?

		globalRetries = new Integer(AutomationUtility.getProperty("uitest.retryCount", "-1")).intValue();

		/**
		 * IMPLEMENT TEST DRIVER BODY HERE
		 */

		// Loop here so we can process multiple test bin files per invocation. Each test file will 
		// fail on the first error it encounters, but we will then proceed on to the next test to 
		// run unless stopOnFirstFailure is set to "true"

		long testSuiteStartTime = new Date().getTime();

		boolean testSuccessful = true;
		while (keyset.hasNext()) {

			retries = 0; // we have not run the test yet

			binFilePath = keyset.next();	// the full path to the test bin file

			testsAttempted++;

			// Retry the test multiple times if the "retry" option is set in the config section of 
			// the bin file or the global uitest.retryCount was set in the props file.

			do {
				// Create a new instance of our performance monitoring object. A new one for each test.

				performanceDriver = new PerformanceDriver(binFilePath);

				try {

					// Initialize test global variables - done before each test

					initializeTestInteractionVariables();

					// For each test file to run, create a test task object for the HTML log

					testTask = Logger.startTestTask("TEST " + testsAttempted + ": Go run the bin file: " + binFilePath);

					// Here we go ... process the file line-by-line
					AutomationBaseTest.setVerificationFailuresToNull();
										
					try{
						processTestFileLineByLine(browser, // the browser instance
								binFilePath,	// bin file full path
								new JSONObject(searchObject.getFileContents(binFilePath)), // JSONObject from bin file contents
								null, // Hash table of args (only used by CALLOUT)
								null, // DataFile object for this test
								new Hashtable<String, String>(), // Hash table of makeVariables
								false); // not in a CALLOUT bin file
					}
					catch(org.apache.commons.json.JSONException je){
						System.out.println("Invalid JSON structure in recording");
						Utils.processStackTrace(je);
						testTask.setStatus(ITestResult.FAILURE);
						testSuccessful = false;
						CustomReporter.incrementDriverTestsFailed();
					}

					// If no exception was thrown, the test was successful

					testTask.setStatus(ITestResult.SUCCESS);
					CustomReporter.incrementDriverTestsPassed();

					Logger.logInfo("END executing the bin file: " + binFilePath);
					testSuccessful = true;
				}

				// All exceptions will percolate up here as we execute a bin test file.
				// We'll catch all exceptions in the top level, so we can terminate on the
				// first problem we encounter - why continue? Why continue indeed! Just go
				// on to the next test.

				catch (Exception ioe) {

					Logger.getScreenshot(getCurrentBrowserIndex());
					Utils.logSevere("ERROR: Execution stopped for recorded test bin file: " + binFilePath);

					//	Set the test status to failure.

					Utils.processStackTrace(ioe);
					testTask.setStatus(ITestResult.FAILURE);
					testSuccessful = false;

					// Take the exception information - write it to the console
					// and also log relevant portions to the test result HTML log.

					// Do we need to retry this test?
					if (retries - 1 > 0) {
						//we want to give the retry a chance to pass..
						//so don't fail unless there are no more retries left
						CustomReporter.incrementDriverTestsRetried();
						Utils.logWarning("Test failed - will retry!");
					} else{
						// Since we caught an exception, set the test task status to failure,
						// so the report will code it red in the HTML log file.						
						CustomReporter.incrementDriverTestsFailed();
					}
				}

				//	Do all the necessary clean-up after a test has run

				Logger.detailsFine("Do test cleanup ...");

				//	Make sure our browser variable points to the currently visible instance - 
				//	in case a new instance had been created (LOGINNEWINSTANCE) or 
				//	switched to (SWITCHINSTANCE) in the last test

				browser = getBrowserInstance(getCurrentBrowserIndex());
				
				// Log out of and close down any multiple browser instances currently open
				// for this test before proceeding to the next test or retrying the current test.

				//	Minimize the currently displayed browser instance if it is not the last
				//	on we created.

				if (getTotalBrowserInstances() > 1 && getCurrentBrowserIndex() != getTotalBrowserInstances()) {
					browser.getDriver().manage().window().setSize(new Dimension(defaultWindowSize.getWidth(), 0));
				}

				//	Close down the browser instances in the reverse order of their creation. Leave the
				//	first one created - we'll use that one for the next test.

				for (int i = getTotalBrowserInstances(); i >= 2; i--) {
					browser = getBrowserInstance(i);
					browser.getDriver().manage().window().setSize(defaultWindowSize);
					if(isLoggedInForInstance(i)) {
						Utils.logInfoInColor(JSON_TEXT_COLOR, "Logging out of browser instance: " + i);
						//	If not on the login page, then try to logout before closing the browser. 
						//	Catch any exception logout may cause or else the driver will terminate.
						try {
							if(!browser.onLogInPage()) {
								browser.logout(); // this will also close any open dialogs
							}
						} catch(Exception e) {
							Utils.logWarning("Could not log out of browser instance: " + i);
						}
						Utils.logInfoInColor(JSON_TEXT_COLOR, "Closing browser instance: " + i);
						browser.close();// close the actual browser instance
						setLoggedInForInstance(i, false);
					}
					setBrowserInstance(i, null);
				}

				// Set everything back to the first browser instance for the next run.
				// Could move this to initializeTestInteractionVariables().

				if (getTotalBrowserInstances() > 1)
					Utils.logInfoInColor(JSON_TEXT_COLOR, "Returning control to browser instance: 1");
				setTotalBrowserInstances(1);
				setCurrentBrowserIndex(1);
				browser = getBrowserInstance(1);
				browser.getDriver().manage().window().setSize(defaultWindowSize); // in case it was minimized
				//	If on the login page, set loggedIn to false
				try {
					if(browser.onLogInPage())
						setLoggedInForInstance(1, false);
					//	Otherwise, if any dialogs are currently popped-up close them so the next test can proceed
					
						else if(browser.anyOpenDialogsDisplayed()) {
							//	If any dialogs are displayed, fail the test if it hasn't previously
							//	failed. Open dialogs at the end of the test are not allowed.
							//	If up to now the test was successful, fail it.
							if(testSuccessful) {
								Logger.getScreenshot(1);
								Utils.logSevere("Found an open dialog after test execution. Failing test!");
								testTask.setStatus(ITestResult.FAILURE);
								testSuccessful = false;
								CustomReporter.incrementDriverTestsFailed();
								CustomReporter.decrementDriverTestsPassed();
								browser.closeAnyOpenDialogsIfDisplayed();
								if(browser instanceof TpaeBrowser) {
									browser.click("titlebar-tb_homeButton");
									browser.closeAnyOpenDialogsIfDisplayed();
								}
							}
							else{
								// Close the open dialogs so the next test starts cleanly.
								browser.closeAnyOpenDialogsIfDisplayed();
								if(browser instanceof TpaeBrowser) {
									browser.click("titlebar-tb_homeButton");
									browser.closeAnyOpenDialogsIfDisplayed();
								}
							}

						}
				} catch(Exception e) {

				}
				
				// Remove any trace of the data output file
				dataOutputFile = null;

				if(testSuccessful && !AutomationBaseTest.getVerificationFailures().isEmpty())
				{
					testTask.setStatus(ITestResult.FAILURE);
					testSuccessful = false;
					CustomReporter.decrementDriverTestsPassed();
					CustomReporter.incrementDriverTestsFailed();
				}

				//	Log the test success/fail message

				if(testSuccessful)
					Utils.logInfoInColor(SUCCESS_COLOR, "TEST SUCCESSFUL");
				else {
					Utils.logSevere("TEST FAILED");
				}

				// After the test has run, process any performance data collected. We'll do this 
				// whether the test passes or fails. In a failure, we'll at least be able to get 
				// data up to the point where it failed. But, only generate the report if the 
				// generate performance report property was set (uitest.generate.perf.report).

				if ("true".equalsIgnoreCase(generatePerfReport))
					performanceDriver.processPerformanceData();

				//	Log the  end of test time-stamp (includes clean-up time)
				testTask.setEndDate(new java.util.Date());

				// If (1) the last run was a failure, and (2) we have retires left then decrement retries and run this test again.

			} while ((testTask.getStatus() == ITestResult.FAILURE) && (--retries > 0));

			//	Stop all testing if uitest.stop.on.first.failure=true and the previous test failed
			//	Just break out of out test loop.

			if("true".equalsIgnoreCase(stopOnFirstFailure) && (testTask.getStatus() == ITestResult.FAILURE))
				break;
		}

		long testSuiteEndTime = new Date().getTime();

		/**
		 * END - log out/close down and record test summary information.
		 */

		if (isLoggedInForInstance(getCurrentBrowserIndex())) {
			Logger.startTestTask("Log out and close down the browser");
		} else {
			Logger.startTestTask("Close down the browser");
		}

		if (testsAttempted == 0)
			Logger.logInfo("Could not find any test bin file names to run. I think we're done.");
		else {
			Logger.logInfo("Could not find any more test bin file names to run. I think we're done.");
		}

		Logger.logInfo("Total number of tests attempted = " + testsAttempted);
		Logger.logInfo("Total number of tests passed = " + CustomReporter.getDriverTestsPassed());
		Logger.logInfo("Total number of tests failed = " + CustomReporter.gettDriverTestsFailed());

		// Log out (should only be one browser instance showing at this point).

		if (isLoggedInForInstance(getCurrentBrowserIndex())) {
			Utils.logInfoInColor(JSON_TEXT_COLOR, "Logging out ...");
			//	If not on the login page, then try to logout before closing the browser. 
			//	Catch any exception logout may cause or else the driver will terminate.
			try {
				if(!browser.onLogInPage()) {
					browser.logout();	// this will also close any open dialogs
				}
			} catch(Exception e) {
				Logger.getScreenshot(getCurrentBrowserIndex());
				Utils.logWarning("Could not log out of browser instance: " + getCurrentBrowserIndex());
			}

			setLoggedInForInstance(getCurrentBrowserIndex(), false);
		}

		//	Close down the browser instance

		Utils.logInfoInColor(JSON_TEXT_COLOR, "Closing browser instance: " + getCurrentBrowserIndex());
		browser.getDriver().quit();
		Logger.detailsFine("TestDriver.Driver() - done");

		//	Log any performance data that was collected
		String time = CustomReporter.secToHHMMSS((testSuiteEndTime - testSuiteStartTime) / 1000);
		Logger.detailsFine("Total Test Suite Execution Time (minus driver setup/tear-down): " + time + " (" + ((testSuiteEndTime - testSuiteStartTime) / 1000) + " seconds)");
		logPerformanceData(browser);

		// If any test has failed, we create a "dummy" test task here and report that the driver
		// failed. This will cause the test suite to report a failure in the test HTML report.
		// We need to process thru all test files and then report a summary success or failure -
		// thus the dummy test task we create here and "fail".

		if (CustomReporter.gettDriverTestsFailed() > 0) {
			Logger.startTestTask("Do not report");
			browser.driverFail("TestDriver.Driver(): Driver Failed"); // forces the HTML log to show an overall failure
		}

		Logger.detailsFine("TestDriver.Driver() - done");
	}

	public Browser getBrowser() {
		return super.getBrowser();
	}

	/**
	 * Initialize the global variables that will keep track of what the next
	 * statement is to execute for "if", "for" and "while" loops.
	 * 
	 */

	private void initializeTestInteractionVariables() {
		Logger.detailsFiner("TestDriver.initializeTestInteractionVariables()");

		// Initialize our last executed and current test step

		currentStep = "None";		//	set in ExecutingtestStep event (the current test step we're working on)
		lastSuccessfulStep = "None";//  from the data input file (the last test step we successfully executed)

		// Keep track of what interaction we need to be on - used for looping (for and while loops)

		currentInteraction = new Stack<Integer>();

		// "if" condition initialization

		ifConditionIsTrue = false; 				// is the if condition true or false
		ifStatements = new Stack<Boolean>(); 	// a stack of "if" interaction indexes for embedded if's
		ignoreIfCnt = 0; 		// when we need to ignore embedded if-else-endif interactions

		// "for" loop initialization

		gotoEndFor = false; 		// will become true when the for condition returns false
		breakLoop = false;
		forStatements = new Stack<Integer>(); // a stack of "for" interaction indexes for embedded for's
		ignoreForCnt = 0; 		// when we need to ignore embedded for interactions

		// "while" loop initialization

		gotoEndWhile = false; 			// will become true when the while condition returns false
		whileStatements = new Stack<Integer>(); // a stack of "while" interaction indexes for embedded while's
		ignoreWhileCnt = 0; 	// when we need to ignore embedded while interactions

		weAreInBVTSetup = false; // will become true if we run a test with the keyword "setup"

		Logger.detailsFiner("TestDriver.initializeTestInteractionVariables() - done");
	}

	/**
	 * Process any command line arguments. These will override their
	 * corresponding properties in the properties file. Setting these allow us
	 * to run the TestDriver from the command line. UCD (continuous delivery)
	 * will be using this.
	 * 
	 */

	private void processAnyCommandLineArgs() {
		Logger.detailsFiner("TestDriver.processAnyCommandLineArgs()");

		String user = System.getProperty("uitest.defaultUser"); 	// user id for logging in
		String pswd = System.getProperty("uitest.defaultPassword"); // password for logging in
		String url = System.getProperty("uitest.defaultURL"); 		// default URL of application
		String tenant = System.getProperty("uitest.tenantCode"); 	// tenant code for logging in
		String lang = System.getProperty("uitest.langCode"); 		// language code for logging in
		String test = System.getProperty("uitest.bin.file"); 		// the test bin file name (e.g. Test.bin)
		String testFolder = System.getProperty("uitest.input.directory"); // the relative path where the test bin file is located
		String libFolder = System.getProperty("uitest.library.directory");// the relative path where callouts are located for this test
		String testRootFolder = System.getProperty("uitest.root.folder"); // the root folder that contains the tests
		String stopOnFirstFailure = System.getProperty("uitest.stop.on.first.failure"); // stop on first failure?
		String ignoreLastStep = System.getProperty("uitest.ignore.laststep"); // ignore the lastStep in the input data file
		String globalRetries = System.getProperty("uitest.retryCount"); // global retry override count
		String featureToggle = System.getProperty("uitest.use.feature.toggle"); // global setting for feature toggle
		String logEventElapsedTime = System.getProperty("uitest.log.event.elapsedTime"); // log event elapsed time for UI events
		String takeScreenshots = System.getProperty("uitest.takeScreenshots");

		//	Now, for each of the properties we can expect from the command line (above), if the
		//	property was present (not null) and had a value (not the null string), then use that
		//	as our runtime property, overriding what is in the propertied file.

		if (logEventElapsedTime != null && !logEventElapsedTime.equals(""))
			AutomationUtility.setProperty("uitest.log.event.elapsedTime", logEventElapsedTime);

		if (takeScreenshots != null && !takeScreenshots.equals(""))
			AutomationUtility.setProperty("uitest.takeScreenshots", takeScreenshots);
				
		if (featureToggle != null && !featureToggle.equals(""))
			AutomationUtility.setProperty("uitest.use.feature.toggle", featureToggle);

		if (globalRetries != null && !globalRetries.equals(""))
			AutomationUtility.setProperty("uitest.retryCount", globalRetries);

		if (ignoreLastStep != null && !ignoreLastStep.equals(""))
			AutomationUtility.setProperty("uitest.ignore.laststep", ignoreLastStep);

		if (stopOnFirstFailure != null && !stopOnFirstFailure.equals(""))
			AutomationUtility.setProperty("uitest.stop.on.first.failure", stopOnFirstFailure);

		if (testRootFolder != null && !testRootFolder.equals(""))
			AutomationUtility.setProperty("uitest.root.folder", testRootFolder);

		//	If uitest.defaultUser was passed in on the command line, we need
		//	to proceed as if uitest.defaultUser2 does not exist
		if (user != null && !user.equals("")) {
			AutomationUtility.setProperty("uitest.defaultUser", user);
			AutomationUtility.setProperty("uitest.defaultUser2", null); // will remove the property
		}

		//	If uitest.defaultPassword was passed in on the command line, we need
		//	to proceed as if uitest.defaultPassword2 does not exits
		if (pswd != null && !pswd.equals("")) {
			AutomationUtility.setProperty("uitest.defaultPassword", pswd);
			AutomationUtility.setProperty("uitest.defaultPassword2", null); // will remove the property
		}

		if (url != null && !url.equals(""))
			AutomationUtility.setProperty("uitest.defaultURL", url);

		if (testFolder != null && !testFolder.equals("")) {
			AutomationUtility.setProperty("uitest.input.directory", testFolder);

			// Loop and make the rest of the uitest.input.directory-n settings null so
			// we don't try to use them if they are also specified in the properties file

			for (int i = 1; i < PropsFileSearch.NUMBER_OF_POSSIBLE_BIN_FOLDERS; i++) {
				AutomationUtility.setProperty("uitest.input.directory-" + i, null);
			}
		}

		if (libFolder != null && !libFolder.equals("")) {

			AutomationUtility.setProperty("uitest.library.directory", libFolder);

			// Loop and make the rest of the uitest.library.directory-n settings null so
			// we don't try to use them if they are also specified in the properties file

			for (int i = 1; i < PropsFileSearch.NUMBER_OF_POSSIBLE_BIN_FOLDERS; i++) {
				AutomationUtility.setProperty("uitest.library.directory-" + i, null);
			}
		}

		if (test != null && !test.equals("")) {

			AutomationUtility.setProperty("uitest.bin.file", test);

			// Loop and make the rest of the uitest.bin.file-n settings null so
			// we don't try to run them if they are also specified in the
			// properties file

			for (int i = 1; i < PropsFileSearch.NUMBER_OF_POSSIBLE_BIN_FILES; i++) {
				AutomationUtility.setProperty("uitest.bin.file-" + i, null);
			}

			// If we're specifying a test from the command line, override the tenant code and language code
			// properties, even if they are null. Don't use the properties file values (per a discussion
			// w/Kristin).

			AutomationUtility.setProperty("uitest.tenantCode", tenant);
			AutomationUtility.setProperty("uitest.langCode", lang);
		}

		Logger.detailsFiner("TestDriver.processAnyCommandLineArgs() - done");
	}

	/**
	 * Read in a JSON bin file that has been previously recorded and step thru
	 * it, processing the configuration section and then executing each "event".
	 * 
	 * @param browser
	 *            an instance of TpaeBrowser
	 * @param binFilePath
	 *            the full path to the JSON test file that will be processed
	 * @param binObject
	 *            the JSONObject of the contents of the test file
	 * @params args
	 *            a hash table of arguments passed into the bin file (used
	 *            when passing parameters to a callout; null when processing a test bin file)
	 * @param dataFileVars
	 *            DataFile object to hold data from our dataInputFile, if
	 *            specified
	 * @param makeVars
	 *            a hash table used to hold any variables defined with the
	 *            "makeVariable" event while processing this test bin file. FYI
	 *            - variables are not kept across test bin file invocations, or
	 *            any embedded "callouts". For "callouts", this hash table will
	 *            contain data from its dataInputFile, if one was specified.
	 * @param inACallout
	 *            true if this was called from CALLOUT, else false. It is used
	 *            to determine if we create a data output file at the end of the
	 *            bin file execution.
	 * @throws Exception
	 *             if one of the events being processed throw an exception
	 */

	private final void processTestFileLineByLine(Browser browser, String binFileFullPath,
			JSONObject binObject, Hashtable<String, String> args,
			DataFile dataFileVars, Hashtable<String, String> makeVars,
			boolean inACallout) throws Exception {

		Logger.detailsFiner("TestDriver.processTestFileLineByLine()");

		String lastStep = "None"; // By default start each test at the beginning

		currentInteraction.push(new Integer(0)); // Initialize the current bin file interaction location

		// Hash table to hold the event parameters from the current JSON line

		Hashtable<String, String> params = new Hashtable<String, String>();

		Logger.logInfo("START executing the bin file: " + binFileFullPath);

		// **************************************************************************
		// Process the "configuration section". It is an optional section, so
		// if it does not exist just proceed. Remember, only test bin files can
		// have a "configuration" section. Callouts do not have one.
		// **************************************************************************

		if (binObject.has("configuration")) {
			JSONObject binConfig = binObject.getJSONObject("configuration");
			try {
				Logger.logInfo("Processing \"configuration\" section of bin file: "	+ binFileFullPath);

				// Color the JSON configuration blue in the log file
				Utils.logInfoInColor(JSON_TEXT_COLOR, "CONFIGURATION: "	+ binConfig.toString());

				//	See if we are running BVTSeup - this has a "keyword" of "setup". We need to know this
				//	in case a userName/password gets created during this  test - it needs to be saved to 
				//	the properties file.
				if (binConfig != null && binConfig.has("keywords")) {
					JSONArray testKeywords = binConfig.getJSONArray("keywords");
					if(testKeywords.toString().contains("\"setup\""))
						weAreInBVTSetup = true;
				}

				// Process the startApp configuration setting if one exists.
				// This tells us what app to start the test in. 

				if (binConfig != null && binConfig.has("startApp")) {
					int currentBrowserInstance = getCurrentBrowserIndex();
					if (!isLoggedInForInstance(currentBrowserInstance)) {
						Logger.logInfo("Logging directly in to app " + binConfig.getString("startApp"));
						setAppForInstance(currentBrowserInstance, binConfig.getString("startApp"));

						//	Use username2/password2 first if they exist. If that fails, use user/password.
						if((browser instanceof TpaeBrowser) && !AutomationUtility.getProperty("uitest.defaultUser2").equals("")) {
							try {
								browser.logInToAppWithUser2(getAppForInstance(currentBrowserInstance));
							} catch(Exception e) {
								browser.logInToApp(getAppForInstance(currentBrowserInstance));
							}
						}
						else {
							browser.logInToApp(getAppForInstance(currentBrowserInstance));
						}

						setLoggedInForInstance(currentBrowserInstance, true);
						makeVars.put("$BROWSER_INSTANCE", new Integer(currentBrowserInstance).toString());
					} else {
						Logger.logInfo("Go to app "	+ binConfig.getString("startApp"));
						browser.waitForWaitlayer(30); // wait at most 30 seconds for TPAE to load
						String nextApp = binConfig.getString("startApp");
						//	Go to the app, but close any open dialogs first
						browser.gotoApp(getAppForInstance(currentBrowserInstance), nextApp, true); 
						setAppForInstance(currentBrowserInstance, nextApp);
					}
				}

				if (binConfig != null && (binConfig.has("dataInputFile") || binConfig.has("dataOutputFile"))) {

					// Go parse the data file

					ArrayList<String> dataInputFiles = new ArrayList<String>();
					String dataInputFile = null;
					//String[] dataInputFile = new ;
					if (binConfig.has("dataInputFile")) {
						dataInputFile = binConfig.getString("dataInputFile");
						dataInputFiles.add(0, dataInputFile);
						Logger.detailsFine("Found data input file: " + dataInputFile);
						int i = 1;
						while (i < 5)
						{
							// Search for additional input files
							if (binConfig.has("dataInputFile-"+ i))
								dataInputFile = binConfig.getString("dataInputFile-" + i);
							else
								break;
							dataInputFiles.add(i, dataInputFile);
							i++;
						}
					}
					if (binConfig.has("dataOutputFile")) {
						dataOutputFile = binConfig.getString("dataOutputFile");
						Logger.detailsFine("Found data output file: " + dataOutputFile);
					}
					dataFileVars = new DataFile(uitestRootFolder,dataInputFiles, dataOutputFile);

					// 	See if we have a previously recorded lastStep and ignoreLastStep is "false".
					//	If so, use the last step from the data input file, if one exists. Otherwise,
					//	if ignoreLastStep is "true", start at the beginning of the test.

					if ("false".equalsIgnoreCase(ignoreLastStep)) {
						String value = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, "$lastStep", true);
						if (value != null & !value.equals("")) {
							Logger.logInfo("Last successfuly step executed was:  " + value);
							startingStep = lastSuccessfulStep = lastStep = value;
						}
					}
				}

				// Process the "gloablRetries" property or configuration setting if one exists.
				// This tells the driver how many times to retry the test if it fails.

				//	Is the global retries property set?
				if(globalRetries > -1 && retries == 0) {
					retries = (globalRetries == 0) ? 0 : globalRetries + 1;
					//else, global retry property is not set, so use bin config retry section if set
				} else if (binConfig != null && binConfig.has("retry")	&& retries == 0) {
					try {
						retries = new Integer(binConfig.getString("retry")).intValue() + 1;
					} catch (NumberFormatException nfe) {
						retries = 0;
						Utils.logSevere("Bad value (non-numeric) found for retry attribute in bin file configuration section: "
								+ binConfig.getString("retry"));
						throw nfe;
					}
				}

			} catch (Exception je) {

				// If an exception happens processing the contents of the
				// "configuration" section, throw the exception back so it
				// percolates up to our main routine - basically we're
				// done with the current test file.

				throw je;
			}
		}

		// **************************************************************************
		// Process the "interactions" section. It is an optional section, so
		// if it does not exist just proceed.
		// **************************************************************************

		if (binObject.has("interactions")) {
			try {

				// Parse the JSON string to a JSONArray

				JSONArray interactions = binObject.getJSONArray("interactions");

				// Initialize the JSON array holder in the Performance Driver to the right
				// size. It is more efficient to specify the initial capacity. If you don't
				// do this, the internal array will have to be repeatedly reallocated as the
				// list grows. In Java, an initial default ArrayList size is 10. Each time capacity is
				// reached, internally a new and larger ArrayList is created and the old data
				// copied to it. This is achieved by having each reallocation increase the
				// size of the array exponentially, typically by a factor of 1.5. With this
				// approach, the total number of operations can be shown to be O(n). So, to
				// avoid this reallocation overhead, we'll set our ArrayList in the Performance
				// Driver to the number of interactions in the test bin file plus some extra for
				// potential callouts.

				if (!inACallout)
					performanceDriver.initJSONArray(interactions.length());

				Logger.logInfo("Processing \"interactions\" section of bin file: " + binFileFullPath);

				// For each element/line in the JSON array, parse its parameters and
				// process its "event". Iterate over each element in the interactions array

				boolean foundLastSuccessfulStep = false;
				for (int j = 0; j < interactions.length(); j++) {

					// Update the current bin file interaction location
					
					currentInteraction.pop();
					currentInteraction.push(new Integer(j));
					
					// get the element object					
					JSONObject element = interactions.getJSONObject(j);

					Utils.addElementParamsToBinHashTable(element, params);
					
					// If no ID, but has an xpath, make id==xpath
					if (params.get("id") == null) {
						String xPath = params.get("xpath");
						if (xPath != null) {
							params.put("id", xPath);
						}
					}

					// Ignore JSON objects with no parameters
					if (params.size() != 0) {
						String event = params.get("event");

						// **************************************************************
						// Process test steps
						// **************************************************************
						// Pick up where we left off (only if lastStep was specified in
						// the configuration section. If lastStep was "None", this means
						// we have not successfully run the the first step yet, so start
						// from the beginning - or the data input file does not even have
						// lastStep defined.

						if (!lastStep.equals("None")) {
							// Go until we find "lastStep"
							if (eventIs(event, "executingTestStep") && !foundLastSuccessfulStep &&  lastStep.equals(params.get("stepName"))) {
								foundLastSuccessfulStep = true;
								// Skip this interaction
								continue;
							}
							// Then go to the next "executingTestStep" label
							// and start execution there.
							else if (eventIs(event, "executingTestStep") && foundLastSuccessfulStep) {
								currentStep = lastStep; // the last successful step that was executed
								lastStep = "None"; // so we don't enter this if block again
							} else {
								// Skip this interaction
								continue;
							}
						}

						// *******************************************************
						// Process while statements
						// *******************************************************
						// Skip over "while-endwhile" if need be.

						if (gotoEndWhile) {
							if (eventIs(event, "while")) {
								ignoreWhileCnt++;
								params.clear();
							} else if (eventIs(event, "endwhile") && ignoreWhileCnt > 0) {
								ignoreWhileCnt--;
								params.clear();
							} else if (eventIs(event, "endwhile")) {
								gotoEndWhile = false;
								params.clear();
							}
							continue;
						}

						// *******************************************************
						// Process for statements
						// *******************************************************
						// Skip over "for-endfor" if need be.

						if (gotoEndFor) {
							if (eventIs(event, "for")) {
								ignoreForCnt++;
								params.clear();
							} else if (eventIs(event, "endfor") && ignoreForCnt > 0) {
								ignoreForCnt--;
								params.clear();
							} else if (eventIs(event, "endfor")) {
								gotoEndFor = false;
								params.clear();
							}
							continue;
						}

						// *******************************************************
						// Process if statements
						// *******************************************************
						// Do "if-elseif-else-endif" processing if need be.

						if (!ifStatements.empty()) { 	// pushed by IF event, popped by ENDIF event
							if (ifConditionIsTrue) {
								if (eventIs(event, "else")) {
									ifConditionIsTrue = false;
									elseIfConditionIsTrue = true;
									// Replace our top "if" stack element with the new condition value
									ifStatements.pop();
									ifStatements.push(new Boolean(ifConditionIsTrue));
									continue; // don't log the else
								}
								else if (eventIs(event,"elseif")) {
									ifConditionIsTrue = false;
									ifStatements.pop();
									ifStatements.push(new Boolean(ifConditionIsTrue));
									elseIfConditionIsTrue = true;
									continue;
								}
								// Run this interaction
							} else { // goto else or endif
								ifConditionIsTrue = false;
								// Ignore intervening if-else-endif blocks until
								// we get to the right else or endif
								if (eventIs(event, "if")) {
									ignoreIfCnt++;
									params.clear();
									continue; // ignore this interaction
								} else if (eventIs(event, "endif") && ignoreIfCnt > 0) {
									ignoreIfCnt--;
									params.clear();
									continue; // ignore this interaction
								} else if (ignoreIfCnt > 0){
									params.clear();
									continue; // ignore this interaction
								}
								
								// Look for the else, elseif or endif
								if (eventIs(event, "else")  && !elseIfConditionIsTrue) {
									ifConditionIsTrue = true;
									elseIfConditionIsTrue = true;
									// Replace our top "if" stack element with the new condition value
									ifStatements.pop();
									ifStatements.push(new Boolean(ifConditionIsTrue));
								} else if (eventIs(event, "elseif") && !elseIfConditionIsTrue) {
									//	elseIfConditionIsTrue = true;
									ifConditionIsTrue = true;
									// Replace our top "if" stack element with the new condition value
									ifStatements.pop();
									ifStatements.push(new Boolean(ifConditionIsTrue));
								} else if (!eventIs(event, "endif")) {
									params.clear();
									continue; // ignore this interaction
								}
								// Run the ELSE or ENDIF interaction
							}
						}

						// *******************************************************
						// Pre-Process comments
						// *******************************************************

						// If the interaction has a comment - do parameter substitution on it

						String comment = params.get("comment");
						if (comment != null) {
							comment = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, comment, false);
						}

						// *******************************************************
						// Process other interactions
						// *******************************************************

						// If the interaction has no event, log it and move on
						// to the next event

						if (event == null || event.equals("")) {
							// Color the JSON non-event interactions (like
							// comments) purple in the log file.
							if (comment != null)
								Utils.logInfoInColor(COMMENT_COLOR,
										"INTERACTION " + (j + 1) + " : " + comment);
							else
								Utils.logInfoInColor(COMMENT_COLOR,
										"INTERACTION " + (j + 1) + " : " + interactions.getJSONObject(j));

						} else {
							// Color the JSON interactions blue in the log file; replace the parameter in the comment if there is one
							JSONObject interaction = interactions.getJSONObject(j);
							if (interaction.containsKey("comment"))
							{
								String interactionComment = interaction.get("comment").toString();
								interactionComment = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, interactionComment, false);
								interaction.put("comment", interactionComment);
							}
							Utils.logInfoInColor(JSON_TEXT_COLOR,
									"INTERACTION " + (j + 1) + " : " + interactions.getJSONObject(j));

							// Process this event

							processEvent(browser, event, element, args, params, makeVars, dataFileVars, binFileFullPath);

							//	Make sure our browser variable points to the correct instance - 
							//	in case a new instance had been created (LOGINNEWINSTANCE) or 
							//	switched to (SWITCHINSTANCE) in the last event executed

							browser = getBrowserInstance(getCurrentBrowserIndex());
						}

						// Clear out the params hash table for the next event
						params.clear();

					}

					// Used for for and while looping - if we're looping, the top value in currentInteraction
					// might have been reset to the beginning of the for/while loop (in ENDFOR or ENDWHILE)

					if (currentInteraction.peek().intValue() != j) {
						j = currentInteraction.peek().intValue() - 1;
					}
				}
			} catch (Exception je) {
				Logger.detailsFiner("TestDriver.processTestFileLineByLine() - exception taken");

				//	Update the properties file with user2/password2 if need be
				if(weAreInBVTSetup && makeVars.get("$username") != null) {
					AutomationUtility.updatePropsFileWithUserName2(makeVars.get("$username"), makeVars.get("$password"));
				}

				// Callout makeVars will be written out in the callout() method itself. Remember, this method
				// might be called multiple times for a single callout if we're looping thru the callout. So,
				// we don't want to be rewriting the output file each time and overwriting the previous data.

				if (dataFileVars != null && !inACallout) {
					makeVars.put("$lastStep", lastSuccessfulStep);
					writeOutputDataFile(dataFileVars, makeVars, startingStep);
				}

				// If an exception happens processing the contents of the
				// "interactions" section, throw the exception back so it
				// percolates up to our main routine - basically we're done with the
				// current test file.

				throw je;
			}
		}

		//	Update the properties file with user2/password2 if need be
		if(weAreInBVTSetup && makeVars.get("$username") != null) {
			AutomationUtility.updatePropsFileWithUserName2(makeVars.get("$username"), makeVars.get("$password"));
		}

		// Callout makeVars will be written out in the callout() method itself. Remember, this method
		// might be called multiple times for a single callout if we're looping thru the callout. So,
		// we don't want to be rewriting the output file each time and overwriting the previous data.

		if (dataFileVars != null && !inACallout) {
			if (!dataFileWasAppended) {
				makeVars.put("$lastStep", currentStep);
				writeOutputDataFile(dataFileVars, makeVars, startingStep);
			}
			else {
				makeVars.put("$lastStep", currentStep);
				makeVars.remove("$BROWSER_INSTANCE");
				dataFileVars.updateOutputDataFile(makeVars); // standard (single set of data) format output
			}
				
		}

		// Remove the current bin file interaction location (might be for a CALLOUT that just finished)

		currentInteraction.pop();

		Logger.detailsFiner("TestDriver.processTestFileLineByLine() - done");
	}

	/**
	 * Write out the data output file. This method will determine whether to
	 * update or overwrite the output data file and then process it accordingly.
	 * We'll overwrite the data output file if we started the test from the
	 * beginning (i.e. lastStep=None), otherwise we'll update the data output
	 * file.
	 * 
	 * @param dataFileVars
	 *            a DataFile object for the data output file
	 * @param makeVars
	 *            a hash table of the JSON key/value parameters associated with
	 *            any makeVariables processed
	 * @param startingStep
	 *            determines if we need to overwrite or append to the existing
	 *            data output file. A value of "None" means overwrite the file.
	 * @throws Exception
	 *             if there was an error writing the data output file
	 */

	private void writeOutputDataFile(DataFile dataFileVars,
			Hashtable<String, String> makeVars, String startingStep)
					throws Exception {

		Logger.detailsFiner("TestDriver.writeOutputDataFile()");

		try {
			//	$BROWSER_INSTANCE is in the makeVars table for easy access by the test scripts - remove it
			//	before saving the data file

			makeVars.remove("$BROWSER_INSTANCE");

			// If startingStep is "None" just overwrite the data output file because
			// we started from the beginning of the test. Be aware though, BVTSetup
			// sets the last statement of its bin file to
			//		{"event":executingTestStep, "stepName":"None"}
			// so that the next time it executes it runs from the beginning.

			if (startingStep.equals("None")) {
				dataFileVars.writeOutputDataFile(makeVars); // overwrite existing data file
			}

			// Otherwise, we've processed at least one test step previously, so
			// we need to just update the data output file to preserve what was previously in there.

			else {
				dataFileVars.updateOutputDataFile(makeVars);// update existing data file
			}
		} catch (Exception e) {
			throw e;
		}

		Logger.detailsFiner("TestDriver.writeOutputDataFile() - done");
	}

	/**
	 * Process each event, calling the appropriate method in this class or super class. 
	 * The method name called is the upper case version of the event name. For example, 
	 * if the event name is "click", we'll call the method "CLICK()" using introspection.
	 * 
	 * @param browser
	 *            the current Browser class instance
	 * @param event
	 *            the event name for the current interaction
	 * @param element
	 *            the JSON element for the current interaction to be executed
	 * @param args
	 *            a hash table of arguments that might have been passed in to
	 *            this bin file. This is only used for callout bin files
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the next object/event to be processed.
	 * @param makeVars
	 *            a hash table of the key/value parameters associated with nay
	 *            makeVars performed by this bin file
	 * @param dateFileVars
	 *            a hash table of the key/value parameters associated with the
	 *            data input file associated with this bin file
	 * @param fileName
	 *            the full path to the test file
	 * @throws NoSuchMethodException
	 *             if the test file specifies an event that is not supported
	 * @throws Exception
	 *             if one of the events being processed throw an exception
	 */

	//	This is the signature for the "event" methods that get called thru introspection
	private static final Class<?> methodParamTypes[] = { Browser.class, Hashtable.class,
		Hashtable.class, Hashtable.class, DataFile.class };

	private void processEvent(Browser browser, String event, JSONObject element,
			Hashtable<String, String> args, Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars,
			String fileName) throws Exception {

		Logger.detailsFiner("TestDriver.processEvent(" + event + ")");

		// From the event name, generate the upper case method name and invoke it
		// thru introspection. This will call one of the event handler methods further below.
		// JSON w/o an event will throw an exception, which will percolate up to our main
		// routine - basically we're done with the current test file.

		String eventUpperCase = event.toUpperCase();

		// Check if we need to login - if we're not logged in and we run into an event that is
		// not a callOut or a gotoApp, then just log in to the Start Center before proceeding.
		// If the first event is login, let the test take care of logging in.
		//	Should only get here thru Tpae. Mobile already logged in from the startApp specified
		// or failed if no startApp was there.

		int currentBrowserInstance = getCurrentBrowserIndex();
		if (!isLoggedInForInstance(currentBrowserInstance) && !eventUpperCase.equals("CALLOUT") && !eventUpperCase.equals("GOTOAPP") && !eventUpperCase.equals("LOGIN")) {
			Logger.detailsFine("Logging in to Start Center");

			//	Use username2/password2 first if they exist. If that fails, use user/password.

			if((browser instanceof TpaeBrowser) && !AutomationUtility.getProperty("uitest.defaultUser2").equals("")) {
				try {
					browser.logInWithUser2();
				} catch(Exception e) {
					browser.logIn();
				}
			}
			else {
				browser.logIn();
			}

			setLoggedInForInstance(currentBrowserInstance, true);
			makeVars.put("$BROWSER_INSTANCE", new Integer(currentBrowserInstance).toString());
			setAppForInstance(currentBrowserInstance, "startcntr");
		}

		performanceDriver.logPreEventData(element);

		try {
			//	Go execute the event method

			Method m = this.getClass().getMethod(eventUpperCase, methodParamTypes);
			m.invoke(this, browser, args, params, makeVars, dataFileVars);

		} catch (NoSuchMethodException nsme) {

			// If we find an invalid "event", throw a NoSuchMethodException, which will
			// percolate up to our main routine - basically we're done with the current test file.

			Utils.logSevere("Unsupported event: '" + event + "' (found in file: " + fileName + ")");
			throw nsme;
		} catch (Exception e) {

			// If Selenium throws an exception from one of the event methods,
			// throw the exception back so it percolates up to our main routine -
			// basically we're done with the current test file.

			throw e;
		}
		finally {

			//	Remember, a finally clause is executed even when an exception is thrown from anywhere in a try/catch block.
			
			performanceDriver.logPostEventData(element);
		}

		// Log the elapsed time if required. Ignore non-user interactions like sleep, makeVariable, etc.

		if ("true".equalsIgnoreCase(logEventElapsedTime) && eventIsUIEvent(eventUpperCase)) {
			Utils.logInfoInColor(ELAPSED_TIME_COLOR, INDENT	+ "Elapsed Time : "
					+ performanceDriver.getLastInteractionElapsedTime()	+ " ms");
		}

		if (breakpointWasCalled){ //if the breakpoint event was called, call again to step through bin file
			BREAKPOINT(browser, args, params, makeVars, dataFileVars);
		}

		Logger.detailsFiner("TestDriver.processEvent(" + event + ") - done");
	}

	/**
	 * Parse a string and replace any $Variables or "random" directive with the
	 * appropriate values. For $Variables it will look for substitutions first
	 * in the contents of any args passed in, then any previous makeVars
	 * created, and finally in the input data file. If the key exists in one of
	 * those places use its corresponding value. Else, use the null string.
	 * If the random directive is used, generate the appropriate random string
	 * or int. This method will preserve spaces in the input string.
	 * 
	 * e.g. "{$ARG} {random:string:6} xxx  {$ARG2}"
	 * 
	 * @param browser
	 *            the current Browser class instance
	 * @param args
	 *            the hash table of arguments passed into the bin file (used for
	 *            callouts only). The keys in this has table start with "$"
	 *            ($ARGS1, $ARGS2, etc.)
	 * @param makeVars
	 *            the hash table of key/value pairs from any makeVars performed
	 *            so far in this bin file. The keys in this has table start with
	 *            "$".
	 * @param dataFile
	 *            the input data file object (containing key/value pairs). The
	 *            keys in this has table start with "$".
	 * @param key
	 *            the search string
	 * @param log
	 *            a boolean that indicates whether or nor to log the
	 *            substitutions
	 * @returns a string with variable substitutions made
	 */

	public String checkForVariableSubstitution(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> makeVars, DataFile dataFile, String key,
			boolean log) {

		Logger.detailsFiner("TestDriver.checkForVariableSubstitution(" + key+ ")");

		String finalString = "";
		boolean subsDone = false;

		boolean containsDollar = false;
		if (key.contains("{$"))
			containsDollar = true;

		if (containsDollar && key.contains("{$"+loopCntr+"}")) {
			String s = makeVars.get("$"+loopCntr);
			key = key.replace("{$"+loopCntr+"}", s);
		}
		
		String tokens[] = key.split("\\{|\\}+");
						
		for (int i = 0; i < tokens.length; i++) {

			String tok = tokens[i];

			if (tok != null) {

				if (tok.startsWith("$") && !tok.startsWith("$.")) {

					String s = null;
					subsDone = true;

					// Check args first

					if (args != null) {
						s = args.get(tok);
					}

					// Check makeVars next

					if (s == null && makeVars != null) {
						s = makeVars.get(tok);
					}

					// Check the input data file next
					if (s == null && dataFile != null) {
						s = dataFile.getVariable(tok);
					}

					//	Finally, check against the latest user and password we are logged in as

					if(s == null && tok.equals("$LOGGED_IN_USER")) {
						s = browser.getCurrentlyLoggedInUser();
					}

					if(s == null && tok.equals("$LOGGED_IN_PASSWORD")) {
						s = browser.getCurrentlyLoggedInPassword();
					}
					
					if(s == null && tok.equals("$DEFAULT_URL")) {
						s = AutomationUtility.getProperty("uitest.defaultURL");
					}

					//	Done looking for substitutions

					if (s != null) {
						if (log)
							Logger.logInfo(INDENT + tok + " value: " + s);
						finalString += s;
					}
					else {
						// If we can't find a substitution value for the
						// $Variable, just return a null string
						Logger.detailsFiner("TestDriver.checkForVariableSubstitution(" + key+ ") - no substitution found - returning null string");
						if (log)
							Logger.logInfo(INDENT + tok + " value: " + "\"\"");
						finalString += "";
					}
				} else if (!containsDollar && !tok.startsWith("random:"))
				{
					finalString = key;
				}
				else if (tok.startsWith("random:")) {
					String randomType = tok.substring(tok.indexOf(':') + 1);
					if (log)
						Logger.detailsFine("	random = " + randomType);
					String random = Randomizer.getRamdomValue(randomType);
					finalString += random;
					subsDone = true;
				} else {
					// Otherwise just use the token - it must be a plain old static string
					// that needs no substitution
					finalString += tok;
				}
			}
		}

		if (subsDone) {
			if (log)
				Logger.detailsFine("TestDriver.checkForVariableSubstitution(): After all substitutions: \""
						+ finalString + "\"");
		}

		Logger.detailsFiner("TestDriver.checkForVariableSubstitution(" + key+ ") - done");
		return finalString;
	}

	//***********************************************************************
	//				Small Helper methods
	//***********************************************************************

	// See if an event string is equal to the name passed in
	private boolean eventIs(String event, String name) {
		if (event != null && !event.equals("") && event.equals(name))
			return true;
		return false;
	}

	//*********************** Browser/App helper methods ***************************
	//
	//	Any event handlers that use global variables should go thru helper methods
	//	to help keep the event handlers self-contained.

	//	Set the app the a specific browser instance is in
	public void setAppForInstance(int browserInstance, String app) {
		curAppForInstance[browserInstance] = app;
	}

	//	Get the app a specific browser instance is in
	public String getAppForInstance(int browserInstance) {
		return curAppForInstance[browserInstance];
	}

	//	Set the current browser instance
	public void setCurrentBrowserIndex(int instance) {
		currentBrowserInstance = instance;
	}

	public void setBrowserInstance(int instance, Browser browser) {
		browserInstance[instance] = browser;
	}

	//	Get the current browser index
	public int getCurrentBrowserIndex() {
		return currentBrowserInstance;
	}

	//	Get the current browser instance
	public Browser getBrowserInstance(int instance) {
		return browserInstance[instance];
	}

	//	Set the number of total browser instances
	public int  setTotalBrowserInstances(int i) {
		return totalBrowserInstances = i;
	}

	// 	Get the total number of browser instances
	public int  getTotalBrowserInstances() {
		return totalBrowserInstances;
	}

	//	Increment the number of total browser instances
	public int  incrementTotalBrowserInstances() {
		return ++totalBrowserInstances;
	}

	//	Set the logged in value for a specific browser instance
	public void setLoggedInForInstance(int browserInstance, boolean isLoggedIn) {
		loggedInForInstance[browserInstance] = isLoggedIn;
	}

	//	Are we logged in in a specific browser instance
	public boolean isLoggedInForInstance(int browserInstance) {
		return loggedInForInstance[browserInstance];
	}

	//*********************** Browser/App helper methods - end ***************************


	/*****************************************************************************************************
	 * Event Handlers - called via introspection based on the "event" names used
	 * in the JSON test bin files. Note: since these methods are invoked thru
	 * introspection, they must all be "public" methods and have the same signature.
	 ***************************************************************************************************/

	//	Hash table to record whether or not an event is a UI event. Each time a new event
	//	is added to the driver, update the hash table. This is used for logging timing
	//	data on UI events. The Tpae driver will register its own events in its respective constructor.

	private static Hashtable<String, Boolean> uiEvent = new Hashtable<String, Boolean>() {
		private static final long serialVersionUID = -1113582265865921787L;
		{
			put("ASSERTATTRIBUTETRUE", new Boolean(false));	// is not a UI event
			put("ASSERTATTRIBUTEFALSE", new Boolean(false));
			put("ASSERTTRUE", new Boolean(false));
			put("ASSERTFALSE", new Boolean(false));
			put("ASSERTPERFTIMER", new Boolean(false));
			put("BREAKPOINT", new Boolean(false));
			put("CALLOUT", new Boolean(true));
			put("CLICK", new Boolean(true));	// is a UI event
			put("CLICKMENU",new Boolean(true));
			put("ELSE", new Boolean(false));
			put("ELSEIF", new Boolean(false));
			put("ENDIF", new Boolean(false));
			put("ENDFOR", new Boolean(false));
			put("ENDWHILE", new Boolean(false));
			put("EXECUTINGTESTSTEP", new Boolean(false));
			put("FAIL", new Boolean(false));
			put("FOR", new Boolean(false));
			put("GOTOAPP", new Boolean(true));
			put("IF", new Boolean(false));
			put("INVOKEJAVAMETHOD", new Boolean(true));
			put("KEYSTROKE", new Boolean(true));
			put("LABEL", new Boolean(false));
			put("LOGIN", new Boolean(true));
			put("LOGINNEWINSTANCE", new Boolean(true));
			put("MAKEVARIABLE", new Boolean(false));
			put("RELOGIN", new Boolean(true));
			put("SCREENSHOT", new Boolean(false));
			put("SELECTCHECKBOX", new Boolean(true));
			put("SLEEP",   new Boolean(false));
			put("STARTTESTSTEP", new Boolean(false));
			put("SWITCHINSTANCE",new Boolean(false));
			put("SWITCHTONEWINSTANCE",new Boolean(false));
			put("RETURNTOORIGINALINSTANCE",new Boolean(false));
			put("TYPEOVER", new Boolean(true));
			put("SELECT", new Boolean(true));
			put("WHILE", new Boolean(false));
		}
	};

	/**
	 *	Determine whether an interaction event is a UI event or not.
	 *  A non-UI event is something like sleep, makeVariable, etc.
	 * 
	 * @param event
	 *            the interaction event name
	 * @returns
	 *            true if the event is a user interaction, else false
	 */
	public boolean eventIsUIEvent(String event) {
		Boolean b = uiEvent.get(event.toUpperCase());
		if(b != null)
			return b.booleanValue();
		else {
			Utils.logWarning("TestDriver.eventIsUIEvent() - missing event in hash table - " + event);
			return false;
		}
	}

	/**
	 *	Register a new event. Used by TpaeTestDriver to add its own unique events.
	 * 
	 * @param event
	 *            the interaction event name
	 * @param isUIEvent
	 *            is the event a UI event. A UI event is something like click, typeOver, etc.
	 *            A non-UI event is something like sleep, makeVariable, etc.
	 */
	public void addEvent(String event, boolean isUIEvent) {
		uiEvent.put(event, new Boolean(isUIEvent));
	}


	/**
	 * Process the "assertTrue" event. Calls the appropriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "assertTrue" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"assertTrue", "id":"m6a7dfd2f_tfrow_[C:1]_txt-tb", "contains": "some value" 
	 * 		}
	 * 
	 * OR instead of "contains", "startsWith":"some value" 
	 * OR "endsWith":"some value" 
	 * OR "equals":"some value"
	 * 	 
	 * You can also assert on a makevar instead of an id (using the same comparisons as above):
	 * 	    { 
	 * 			"event":"assertTrue", "makevar":"{$someVar}",  "contains": "some value"
	 * 		}
	 * 
	 */
	public void ASSERTTRUE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.ASSERTTRUE()");
		eventCounterStart("ASSERTTRUE");

		assertHelper(browser, args, params, makeVars, dataFileVars, true);

		eventCounterStop();
		Logger.detailsFine("TestDriver.ASSERTTRUE() - done");
	}

	/**
	 * Process the "assertFalse" event. Calls the appropriate Browser method
	 * that corresponds to this event.
	 * 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "assertFalse" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"assertFalse", "id":"m6a7dfd2f_tfrow_[C:1]_txt-tb",  "contains": "some value"
	 * 		}
	 * 
	 * OR instead of "contains", "startsWith":"some value" 
	 * OR "endsWith":"some value" 
	 * OR "equals":"some value"
	 * 	
	 * You can also assert on a makevar instead of an id (using the same comparisons as above):
	 * 	    { 
	 * 			"event":"assertFalse", "makevar":"{$someVar}",  "contains": "some value"
	 * 		}
	 * 
	 */
	public void ASSERTFALSE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.ASSERTFALSE()");
		eventCounterStart("ASSERTFALSE");

		assertHelper(browser, args, params, makeVars, dataFileVars, false);

		eventCounterStop();
		Logger.detailsFine("TestDriver.ASSERTFALSE() - done");
	}

	private void assertHelper(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars,
			boolean assertTrue) throws Exception {

		//the following strings are for building the fail message
		String value = null;
		String actual = null;
		String flag = null;

		// assert on a field
		if (params.get("id") != null) {
			String id =  params.get("id").trim();
			Logger.detailsFine(INDENT + "id = " + id);

			// Get the appropriate value from the screen
			browser.waitForWaitlayer();

			WebElement element = browser.getElement(id);

			value = element.getText();
			if(value == null || value.equals("")) {
				value = element.getAttribute("value");
				if (value == null || value.equals(""))
					value = element.getAttribute("innerHTML");
			}
			Logger.detailsFine(INDENT + "value = " + value);

			flag = "id";
			actual = id;
			Logger.detailsFine(INDENT + "id = " + id);
		}
		else if (params.get("makevar") != null) {
			String makevar = params.get("makevar").trim();
			value = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, makevar, true);
			flag = "makevar";
			actual = makevar;
			Logger.detailsFine(INDENT + "makevar =" + makevar);
		}
		if (params.get("contains") != null) {
			String contains = params.get("contains").trim();
			Logger.detailsFine(INDENT + "contains = " + contains);
			contains = checkForVariableSubstitution(browser, args, makeVars,	dataFileVars, contains, true);
			if (assertTrue && !value.contains(contains)) {
				browser.testFail(assertStringBuilder(flag, value, actual, contains, "does not contain"));
			} else if (!assertTrue && value.contains(contains)) {
				browser.testFail(assertStringBuilder(flag, value, actual, contains, "does contain"));
			}
		} else if (params.get("startsWith") != null) {
			String startsWith = params.get("startsWith").trim();
			Logger.detailsFine(INDENT + "startsWith = " + startsWith);
			startsWith = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, startsWith, true);
			if (assertTrue && !value.startsWith(startsWith)) {
				browser.testFail(assertStringBuilder(flag, value, actual, startsWith, "does not start with"));
			} else if (!assertTrue && value.startsWith(startsWith)) {
				browser.testFail(assertStringBuilder(flag, value, actual, startsWith, "does start with"));				
			}
		} else if (params.get("endsWith") != null) {
			String endsWith = params.get("endsWith").trim();
			Logger.detailsFine(INDENT + "endsWith = " + endsWith);
			endsWith = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, endsWith, true);
			if (assertTrue && !value.endsWith(endsWith)) {
				browser.testFail(assertStringBuilder(flag, value, actual, endsWith, "does not end with"));
			} else if (!assertTrue && value.endsWith(endsWith)) {
				browser.testFail(assertStringBuilder(flag, value, actual, endsWith, "does end with"));
			}
		} else if (params.get("equals") != null) {
			String equals = params.get("equals").trim();
			Logger.detailsFine(INDENT + "equals = " + equals);
			equals = checkForVariableSubstitution(browser, args, makeVars,dataFileVars, equals, true);
			if (assertTrue && !value.equalsIgnoreCase(equals)) {
				browser.testFail(assertStringBuilder(flag, value, actual, equals, "does not equal"));
			} else if (!assertTrue && value.equalsIgnoreCase(equals)) {
				browser.testFail(assertStringBuilder(flag, value, actual, equals, "does equal"));
			}
		} else {
			browser.testFail("Did not find expected comparitor: equals, endswith, startswith, contains ");
		}
	}
	/**
	 * Creates the error for the log. 
	 * Ex ERROR:Value[12710] for Element[m6a7dfd2f_tdrow_[C:1]_ttxt-lb[R:0]]does contain[7]
	 * Specifically for the assertHelper method. Builds strings to output if the test fails.
	 * @param flag  Either makevar or id
	 * @param value The value of the field or makevar
	 * @param actual The makevar or id we are comparing ( ex [$value] or m6a7dfd2f_tfrow_[C:1]_txt-tb )
	 * @param phrase  ex "does equal" or "does not equal"
	 * @return
	 */
	private String assertStringBuilder(String flag, String value, String actual, String compareValue, String phrase){
		String failString = null;
		if(flag.equalsIgnoreCase("makevar")){
			failString = "Value[" + value + "] for " + flag + "[" + actual + "]" + phrase + "[" + compareValue + "]";
		}else{
			failString = "Value[" + value + "] for Element[" + actual + "]" + phrase + "[" + compareValue + "]";
		}
		return failString;
	}

	/**
	 * Process the "assertAttributeTrue" event. Calls the appropriate Browser
	 * method that corresponds to this event.
	 * 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "assertAttributeTrue" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"assertAttributeTrue", "id":"m6a7dfd2f_tfrow_[C:1]_txt-tb", 
	 * 				"attribute":"attributeName", "value": "some value" 
	 * 		}
	 * 
	 * where "some value" might be an SQL query like :
	 * 			"sql:select count(*) from {$TABLE}"
	 */

	public void ASSERTATTRIBUTETRUE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.ASSERTATTRIBUTETRUE()");
		eventCounterStart("ASSERTATTRIBUTETRUE");

		assertAttributeHelper(browser, args, params, makeVars, dataFileVars, true, true);

		eventCounterStop();
		Logger.detailsFine("TestDriver.ASSERTATTRIBUTETRUE() - done");
	}

	/**
	 * Process the "assertAttributeFalse" event. Calls the appropriate Browser
	 * method that corresponds to this event.
	 * 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "assertAttributeFalse" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"assertAttributeFalse", "id":"m6a7dfd2f_tfrow_[C:1]_txt-tb",
	 * 					"attribute":"attributeName", "value": "some value" 
	 * 		}
	 * 
	 * where "some value" might be an SQL query like :
	 * 			"sql:select count(*) from {$TABLE}"
	 */

	public void ASSERTATTRIBUTEFALSE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.ASSERTATTRIBUTEFALSE()");
		eventCounterStart("ASSERTATTRIBUTEFALSE");

		assertAttributeHelper(browser, args, params, makeVars, dataFileVars, false, true);

		eventCounterStop();
		Logger.detailsFine("TestDriver.ASSERTATTRIBUTEFALSE() - done");
	}

	private void assertAttributeHelper(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars,
			boolean assertTrue, boolean isAssert) throws Exception {

		Logger.detailsFine("TestDriver.assertAttributeHelper()");

		String id = params.get("id").trim();
		String attribute = params.get("attribute").trim();
		String value = params.get("value"); // Don't trim on purpose

		Logger.detailsFine(INDENT + "id = " + id);
		Logger.detailsFine(INDENT + "attribute = " + attribute);
		id = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, id, true);
		value = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, value, true);
		Logger.detailsFine(INDENT + "value = " + value);

		// Is it an SQL query?
		if (value.startsWith("sql:")) {
			value = value.substring(4); // e.g., select count(*) from maxprop
			value = AutomationUtility.getSQLValue(value);
		}

		if (isAssert)
		{
			if (assertTrue)
				browser.assertAttributeTrue(id, attribute, value);
			else
				browser.assertAttributeFalse(id, attribute, value);
		}
		else
		{
			if (assertTrue)
				browser.verifyAttributeTrue(id, attribute, value);
			else
				browser.verifyAttributeFalse(id, attribute, value);
		}

		Logger.detailsFine("TestDriver.assertAttributeHelper() - done");
	}

	/**
	 * Process the "verifyAttributeTrue" event. Calls the appropriate Browser
	 * method that corresponds to this event.
	 * 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "assertAttributeTrue" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"verifyAttributeTrue", "id":"m6a7dfd2f_tfrow_[C:1]_txt-tb", 
	 * 				"attribute":"attributeName", "value": "some value" 
	 * 		}
	 * 
	 * where "some value" might be an SQL query like :
	 * 			"sql:select count(*) from {$TABLE}"
	 */

	public void VERIFYATTRIBUTETRUE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.VERIFYATTRIBUTETRUE()");
		eventCounterStart("VERIFYATTRIBUTETRUE");

		assertAttributeHelper(browser, args, params, makeVars, dataFileVars, true, false);

		eventCounterStop();
		Logger.detailsFine("TestDriver.VERIFYATTRIBUTETRUE() - done");
	}

	/**
	 * Process the "verifyAttributeFalse" event. Calls the appropriate Browser
	 * method that corresponds to this event.
	 * 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "assertAttributeFalse" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"verifyAttributeFalse", "id":"m6a7dfd2f_tfrow_[C:1]_txt-tb",
	 * 					"attribute":"attributeName", "value": "some value" 
	 * 		}
	 * 
	 * where "some value" might be an SQL query like :
	 * 			"sql:select count(*) from {$TABLE}"
	 */

	public void VERIFYATTRIBUTEFALSE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.VERIFYATTRIBUTEFALSE()");
		eventCounterStart("VERIFYATTRIBUTEFALSE");

		assertAttributeHelper(browser, args, params, makeVars, dataFileVars, false, false);

		eventCounterStop();
		Logger.detailsFine("TestDriver.VERIFYATTRIBUTEFALSE() - done");
	}

	/**
	 * Process the "assertPerfTimer" event. Calls the appropriate Browser method
	 * that corresponds to this event.
	 * 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "assertPerfTimer" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"assertPerfTimer", "time":"2000" 
	 * 		}
	 * 
	 * The time is in milliseconds.
	 */

	public void ASSERTPERFTIMER(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.ASSERTPERFTIMER()");
		eventCounterStart("ASSERTPERFTIMER");

		long time = new Long(params.get("time").trim()).longValue();
		Logger.detailsFine(INDENT + "time = " + time);

		browser.assertPerfTime(performanceDriver.getLastInteractionElapsedTime(), time);

		eventCounterStop();
		Logger.detailsFine("TestDriver.ASSERTPERFTIMER() - done");
	}

	/**
	 * Process the "callout" event. Calls the appropriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "callout" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"callout", "binfile":"file name", "params":"$Asset1, $AssetLoc1, null, $AssetDesc1, true, false", 
	 * 
	 * optional: "prams": used as $ARGS1, $ARGS2, $ARGS3, $ARGS4, etc. in the callout bin file 
	 * optional: "binfileLoc":"C:/src/MobileNext-Rel-2/Automation/properties"
	 * optional: "dataInputFile":"C:/temp/Tests/data/WorkOrderTest.data"
	 * optional: "dataOutputFile":"C:/temp/Tests/data/WorkOrderGeneratedTest.data"
	 *
	 * 		}
	 */

	//	Our callout cache to hold the JSONObjects that represent callout bin files
	private static Hashtable<String, JSONObject> calloutCache = new Hashtable<String, JSONObject>();

	@SuppressWarnings("unchecked")
	public void CALLOUT(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.CALLOUT()");
		Utils.logInfoInColor(CALLOUT_START_COLOR, "*** STARTING CALLOUT EXECUTION ***");

		String binFileLocation = null;
		String binFileFullPath = null;
		String inputDataStr = null;

		String binFileBaseName = params.get("binfile").trim();
		Logger.detailsFine(INDENT + "binfile = " + binFileBaseName);

		// Find the callout bin file location. It was either specified in the test bin file, or
		// we'll go look for it in out LIBRARY settings. If the bin file is not found, a
		// FileNotFoundException will be thrown and will percolate up to our main routine -
		// basically we're done with the current test file.

		binFileLocation = params.get("binfileLoc");
		Logger.detailsFine(INDENT + "binFileLoc = " + binFileLocation);

		if (binFileLocation != null) {
			binFileFullPath = Utils.findFileFullPath(uitestRootFolder, binFileLocation.trim() + File.separator + binFileBaseName);
		} else {
			// If the bin file location was not specified in the JSON, go look for it
			// in any defined library locations in the properties file.

			binFileFullPath = searchObject.getCalloutFilePath(binFileBaseName);
		}

		Logger.logInfo("Processing callout bin file: " + binFileFullPath);

		// Get the test bin file JSON contents - either from our internal callout cache
		// or from the file system. If from the file system, cache it for quick access later.

		JSONObject binObject = calloutCache.get(binFileFullPath);
		if(binObject == null) {
			Logger.detailsFine("Did not find callout in the cache - getting from file system");
			String jsonStr = Utils.readFile(binFileFullPath);

			// Parse the "callout" JSON file. If a JSONException occurs, we'll throw the exception back so it
			// percolates up to our main routine - basically we're done with the current test file.

			try {
				binObject = new JSONObject(jsonStr);
			} catch (Exception je) {
				Utils.logSevere("ERROR parsing callout bin file: " + binFileFullPath);
				throw je;
			}

			//	Cache it

			calloutCache.put(binFileFullPath, binObject);

			Logger.detailsFine("Cached the callout for faster access later.");
		}
		else {
			Logger.detailsFine("Found the callout in the cache.");
		}

		// Look for a "configuration" section in the callout bin file. It is not allowed for callout bin files.
		// If one exists, throw an Exception back so it percolates up to our main routine - basically we're
		// done with the current test file.

		if (binObject.has("configuration")) {

			// If we find a configuration section, we'll throw the exception back so it
			// percolates up to our main routine - basically we're done with the
			// current test file.

			Utils.logSevere("Callout bin file found with \"configuration\" section. This is not allowed.");
			throw new Exception("Callout bin file found with \"configuration\" section. This is not allowed.");
		}

		// Get the location and contents of the input data file and data output file, if they
		// were specified in the callout "event"

		String dataInputFileFullPath = null;
		String dataOutputFilePath = null;

		if (params.get("dataInputFile") != null || params.get("dataOutputFile") != null) {

			// If a dataInputFile was specified, do not create a DataFile object. Instead,
			// we'll iterate over each record of the dataInputFile further below and execute the
			// callout code for each record.

			String dataInputFilePath = params.get("dataInputFile");
			if (dataInputFilePath != null) {
				dataInputFileFullPath = Utils.findFileFullPath(uitestRootFolder, dataInputFilePath);
				Logger.detailsFine("Found callout data input file: " + dataInputFileFullPath);
				Logger.logInfo("Found callout data input file: " + dataInputFileFullPath);
				inputDataStr = Utils.readFile(dataInputFileFullPath);
			}

			// Get the location of the output data file, if one was specified in the
			// callout "event". If one was specified, well also create a DataFile object
			// but use the input data from the calling bin file so we can access those
			// defined variables.

			dataOutputFilePath = params.get("dataOutputFile");
			if (dataOutputFilePath != null) {
				Logger.detailsFine("Found callout data output file: " + dataOutputFilePath);

				// Create a DataFile object, but do not pass the data input file info.
				// This is because we'll process the data file records ourselves further below.

				DataFile parentDataFileVars = dataFileVars;
				dataFileVars = new DataFile(uitestRootFolder, null, dataOutputFilePath);

				// Use/link to the data input information from the parent so that the callout
				// can use the variables defined in it.

				if (parentDataFileVars != null) {
					dataFileVars.setInputDataToParent(parentDataFileVars);
				}
			}
		}

		// Note: at this point, if we have a dataOutputFile specified, we have defined a local dataFileVars
		// and linked to the input data from the calling bin file so we can use those values. Otherwise, we will use
		// the dataFileVars object that was passed in from the parent. We will tell processTestFileLineByLine()
		// that we're invoking it from a CALLOUT, so it does not try to write the output results after it
		// executes each iteration of the callout bin file. We'll do the writing of the output data file here
		// if one was specified in the callout event.

		// Create our hash table to hold each line of data from the input data file.
		// Iterate thru the data, invoking the callout bin file for each line/record.

		Hashtable<String, String> calloutMakeVars = null;

		// Create a hash table for any arguments passed into the callout via the "params".
		// These get defined as $ARGS1, $ARGS2, etc. and can be used in the callout bin file.

		Hashtable<String, String> calloutArgs = processCalloutArgs(browser, args,
				makeVars, dataFileVars, params.get("params"));

		// Create an arrayList to hold any makeVar hash tables created during
		// each iteration thru the data file data

	//	ArrayList<Hashtable<String, String>> outputDataArrayList = new ArrayList<Hashtable<String, String>>();

		if (inputDataStr != null) {
			try {

				// Parse the JSON string to a JSONArray

				JSONArray elements = new JSONArray(inputDataStr);

				// For each element/line in the data array, parse its
				// parameters, populate the makeVars
				// hash table and then invoke the callout bin file for it. We'll
				// invoke the bin file once
				// for each line in the data file.

				for (int j = 0; j < elements.length(); j++) {

					// Color the JSON interactions blue in the log file
					Utils.logInfoInColor(CALLOUT_COLOR, "Callout Loop "
							+ (j + 1) + " - Using Data element: " + (j + 1)
							+ " : " + elements.getJSONObject(j));

					JSONObject element = elements.getJSONObject(j); // Get the element object

					// Clone any makeVars passed in to the callout (sorta like  global variables)

					calloutMakeVars = (Hashtable<String, String>) makeVars.clone();

					// Add the current data record key/value pairs to our
					// calloutMakeVars hash table

					Utils.addElementParamsToDataHashTable(element, calloutMakeVars);

					// Go process the callout bin file with this line of data
					// It'll use the data output info, if any, from the callout but
					// the data input vars will come from the calling bin file so we
					// can access them here.

					processTestFileLineByLine(browser, binFileFullPath, binObject, calloutArgs, dataFileVars, calloutMakeVars, true);

					// Remove the current data record key/value pairs in our makeVars hash table.
					// This leaves just the makeVar data that was passed into or generated from
					// the callout execution itself.

					Utils.removeElementParamsFromHashTable(element,	calloutMakeVars);

					// Remove any vars from our makeVars hash table that came from the calling bin file
					// but were not also created in the callout bin file with the same name but different
					// value object

					Utils.removeCallingVarsFromCalloutVars(makeVars, calloutMakeVars);

					// Save a copy of any makeVars performed for this iteration of the callout
					// bin file. We'll write these to out output data file later, if one was
					// specified.

					if (!calloutMakeVars.isEmpty()) {
						outputDataArrayList.add((Hashtable<String, String>) calloutMakeVars.clone());
					}

				}
			} catch (JSONException je) {
				Utils.logSevere("Error parsing callout data file: "	+ dataInputFileFullPath);
				throw je;
			} catch (Exception e) {
				Utils.logSevere("Error executing callout bin file: "+ binFileFullPath);
				throw e;
			}
		} else {
			// Clone any makeVars passed in to the callout (sorta like global variables)

			calloutMakeVars = (Hashtable<String, String>) makeVars.clone();

			// Go process the callout bin file - using the makeVars from the
			// calling test bin file and the input data file info from the calling test bin file.

			processTestFileLineByLine(browser, binFileFullPath, binObject, calloutArgs,
					dataFileVars, calloutMakeVars, true);

			// Remove any vars from the calling bin file that were not also
			// created in the callout bin file

			Utils.removeCallingVarsFromCalloutVars(makeVars, calloutMakeVars);

			// Save a copy of any makeVars from the callout bin file. We'll
			// write these to out output data file later, if one was specified.

			if (!calloutMakeVars.isEmpty()) {
				outputDataArrayList.add((Hashtable<String, String>) calloutMakeVars);
			}
		}

		// If a dataOutputFile was specified for the callout, write out any
		// makeVars used/created by the callout bin file

		if (dataOutputFilePath != null) {
			if (!dataOutputFilePath.equals(dataOutputFile))
				dataFileVars.writeCalloutOutputDataFile(outputDataArrayList); // record array-format output
			else {
				calloutMakeVars.remove("$BROWSER_INSTANCE");
				dataFileVars.updateOutputDataFile(calloutMakeVars); // standard (single set of data) format output
				dataFileWasAppended = true;
			}
		}

		if (params.get("returnValue") != null) {
			String returnValue = params.get("returnValue").trim();
			makeVars.put("$" + returnValue, calloutReturnValue);
		}
		
		calloutReturnValue = null;
		Logger.logInfo("END executing the callout bin file: " + binFileFullPath);
		Logger.detailsFine("TestDriver.CALLOUT() - done");
		Utils.logInfoInColor(SUCCESS_COLOR, "*** CALLOUT EXECUTION SUCCESSFUL ***");
	}

	// Process the params string from the callout event if one was specified. For
	// each item in the comma-separated string, see if we need to do paramater
	// substitution with any makeVars or the input data file contents from
	// the calling test bin file.

	private Hashtable<String, String> processCalloutArgs(Browser browser,
			Hashtable<String, String> args, Hashtable<String, String> makeVars,
			DataFile dataFile, String params) {

		Hashtable<String, String> calloutArgs = null;
		if (params != null) {
			calloutArgs = new Hashtable<String, String>();
			List<String> items = Arrays.asList(params.split("\\s*,\\s*"));
			int i = 1;
			for (String item : items) {
				calloutArgs.put("$ARGS" + i++, checkForVariableSubstitution(browser, args, makeVars, dataFile, item, true));
			}

		}
		return calloutArgs;
	}
	
	/**
	 * Process the "click" event. Calls the appropriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "click" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"click", "id": "m6a7dfd2f_tdrow_[C:1]_ttxt-lb[R:2]"
	 * 		}
	 */

	public void CLICK(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.CLICK()");
		eventCounterStart("CLICK");

		String idOrXpath = params.get("id").trim();
		idOrXpath = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, idOrXpath, true);
		if (idOrXpath.length() == 0) {
			idOrXpath = params.get("xpath").trim();
			idOrXpath = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, idOrXpath, true);
		}
		Logger.detailsFine(INDENT + "id = " + idOrXpath);

		browser.click(idOrXpath);

		eventCounterStop();
		Logger.detailsFine("TestDriver.CLICK() - done");
	}
	
	/**
	 * Process the "clickMenu" event. Calls the appropriate Browser methods that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "clickMenu" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ "event":"clickMenu", "id":"m6a7dfd2f_tdrow_[C:1]_ttxt-lb[R:2]", "params":[String id, ...]
	 * 		}
	 */

	public void CLICKMENU(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.CLICKMENU()");
		eventCounterStart("CLICKMENU");

		String idOrXpath = params.get("id").trim();
		if (idOrXpath.length() == 0) {
			idOrXpath = params.get("xpath").trim();
		}
		Logger.detailsFine(INDENT + "id = " + idOrXpath);
		String paramsVal = params.get("params").trim();
		if (paramsVal != null) {
			// Parse the JSON "params" string to a JSONArray
			JSONArray elements = new JSONArray(paramsVal);
			for (int index = 0; index < elements.length(); index++) {
				String id = elements.getString(index);
				id = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, id, true);
				browser.waitForElementAndClick(id);
			}
		}

		browser.waitForWaitlayer();
		browser.waitForElementAndClick(idOrXpath);

		eventCounterStop();
		Logger.detailsFine("TestDriver.CLICKMENU() - done");
	}


	/**
	 * Process the "executingTestStep" event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "executingTestStep" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 			{ "event":"executingTestStep", "stepName":"1" }
	 */

	public void EXECUTINGTESTSTEP(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.EXECUTINGTESTSTEP()");
		eventCounterStart("EXECUTINGTESTSTEP");

		lastSuccessfulStep = currentStep; // save the laststep we completed
		currentStep = params.get("stepName");

		eventCounterStop();
		Logger.detailsFine("TestDriver.EXECUTINGTESTSTEP() - done");
	}	

	/**
	 * Process the "fail" event. These can also have embedded "for" events.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "fail" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: {"event":"fail", "message":"string"}
	 */

	public void FAIL(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver:FAIL()");
		eventCounterStart("FAIL");

		String message = params.get("message");
		message = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, message, true);
		Logger.detailsFine("	message = " + message);
		browser.testFail(message);

		eventCounterStop();
		Logger.detailsFine("TestDriver:FAIL() - done");
	}


	/**
	 * Process the "for" event. These can also have embedded "for" events.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "for" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{"event":"for", "params":[i, 1, 10]} 
	 * 			... 
	 * 			... 
	 * 		{"event":"endfor"}
	 * 
	 * For now, we only support incrementing loop counts.
	 */

	boolean gotoEndFor = false; // will become true when the for condition returns false
	Stack<Integer> forStatements = new Stack<Integer>(); // a stack of for interaction indexes for embedded for's
	int ignoreForCnt = 0; 		// when we need to ignore embedded for interactions

	public void FOR(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		boolean forConditionIsTrue = false;
		if (breakLoop)
		{
			forConditionIsTrue = true;
			gotoEndFor = true;
		}

		Logger.detailsFine("TestDriver:FOR()");
		eventCounterStart("FOR <condition>");

		String paramsVal = params.get("params").trim();

		JSONArray elements = new JSONArray(paramsVal);
		loopCntr = elements.getString(0); // e.g. loopCntr
		int startCnt = new Integer(checkForVariableSubstitution(browser, args, makeVars,
				dataFileVars, elements.getString(1), true)).intValue();
		int endCnt = new Integer(checkForVariableSubstitution(browser, args, makeVars,
				dataFileVars, elements.getString(2), true)).intValue();

		// Create or update the loop counter variable in our makeVars

		int curVal = startCnt;
		if (makeVars.get("$" + loopCntr) == null) {
			makeVars.put("$" + loopCntr, new Integer(startCnt).toString());
		} else {
			curVal = new Integer(makeVars.get("$" + loopCntr)).intValue() + 1;
			makeVars.put("$" + loopCntr, new Integer(curVal).toString());
		}

		// Check the loop condition

		forConditionIsTrue = (curVal <= endCnt) ? true : false; // if true, continue looping
		Logger.detailsFine(INDENT + "Loop counter is: " + curVal);

		if (!forConditionIsTrue) {
			// If we have previously saved this for loop location, pop it from
			// the stack because we're done with it
			gotoEndFor = true; // set to false in driver when we reach the endfor statement
			makeVars.remove("$" + loopCntr);
			if (!forStatements.isEmpty()) {
				int loc = forStatements.peek().intValue();
				if (loc == currentInteraction.peek().intValue()) {
					forStatements.pop();
				}
			}
		} else {
			// Save the location of the for loop so that when we hit the "enfor"
			// event we can loop back to
			// the beginning of the for loop
			if (!forStatements.isEmpty()) {
				int loc = forStatements.peek().intValue();
				if (loc != currentInteraction.peek().intValue()) {
					forStatements.push(currentInteraction.peek());
				}
			} else {
				forStatements.push(currentInteraction.peek());
			}
		}

		eventCounterStop();
		Logger.detailsFine("TestDriver:FOR() - done");
	}
	
	/**
	 * Process the "breakLoop" event
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "for" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{"event":"breakLoop"} 
	 */
	public void BREAKLOOP(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {
		
		Logger.detailsFine("TestDriver.BREAKLOOP()");

		// Go back to the beginning of the while loop
		try {
			currentInteraction.pop();
			if (whileStatements.size() > 0)
			{
				currentInteraction.push(whileStatements.peek());
				breakLoop = true;
			}
			if (forStatements.size() > 0)	
			{
				currentInteraction.push(forStatements.peek());
				breakLoop = true;
			}
		} catch (EmptyStackException ese) {
			throw ese;
		}

		Logger.detailsFine("TestDriver.BREAKLOOP() - done");
	}

	/**
	 * Process the "gotoApp" event. Calls the appropriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "gotoApp" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: { "event":"gotoApp", "app":"wotrack" }
	 */

	// 	This will construct and use the correct app url (not goto menu - very fast)

	public void GOTOAPP(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.GOTOAPP()");
		eventCounterStart("GOTOAPP");

		String app = params.get("app").trim();
		app = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, app, true);
		Logger.detailsFine(INDENT + "app = " + app);

		//	If not already logged in, then do a login
		int currentBrowserInstance = getCurrentBrowserIndex();
		if (!isLoggedInForInstance(currentBrowserInstance)) {
			Logger.detailsFine("Logging in to app " + app);

			//	Use username2/password2 first if they exist. If that fails, use user/password.
			if((browser instanceof TpaeBrowser) && !AutomationUtility.getProperty("uitest.defaultUser2").equals("")) {
				try {
					browser.logInToAppWithUser2(app);
				} catch(Exception e) {
					browser.logInToApp(app);
				}
			}
			else {
				browser.logInToApp(app);
			}

			setLoggedInForInstance(currentBrowserInstance, true);
			makeVars.put("$BROWSER_INSTANCE", new Integer(currentBrowserInstance).toString());
			setAppForInstance(currentBrowserInstance, app);
		} else {
			//	Else, goto the app specified
			String nextApp = app;
			//	In mobile, the GOTO directive will cause a login to the new app
			browser.gotoApp(getAppForInstance(currentBrowserInstance), nextApp, false);
			setAppForInstance(currentBrowserInstance, nextApp);
		}

		eventCounterStop();
		Logger.detailsFine("TestDriver.GOTOAPP() - done");
	}

	/*
	 * Format: "{event":"endfor"}
	 */

	public void ENDFOR(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver:ENDFOR()");

		// Go back to the beginning of the for loop
		try {
			currentInteraction.pop();
			currentInteraction.push(forStatements.peek());
		} catch (EmptyStackException ese) {
			Utils.logSevere("Discovered unbalanced for-endfor - possibly found an \"endfor\" event without a corresponding \"for\" event");
			throw ese;
		}

		Logger.detailsFine("TestDriver:ENDFOR() - done");
	}


	/**
	 * Process the "if" event. These can also have embedded if-else-endif events.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "if" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{"event":"if", "condition":"<cond>"} 
	 * 			... // True case ...
	 * 		{"event":"elseif", "condition":"<cond>"}
	 * 			... // True case ...
	 * 		{"event":"else"} // optional 
	 * 			... //False case ... 
	 * 		{"event":"endif"} 
	 * 
	 * After if statement
	 * 
	 * 	where cond looks similar to: ${ARG} == "SomeString" or ${ARG} < 4 or {$ARG1} != {$ARG2}
	 * 
	 * 	using ==, !=, contains, startswith, endswith  for strings and ==, !=, <, <=, >, >= for ints/doubles
	 */

	boolean ifConditionIsTrue = false; 	// is the if condition true or false
	boolean elseIfConditionIsTrue = false;
	Stack<Boolean> ifStatements = new Stack<Boolean>(); 	// a stack of if interaction indexes for embedded if's
	int ignoreIfCnt = 0; 	// when we need to ignore embedded if-else-endif interactions

	public void IF(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.IF()");
		eventCounterStart("IF <condition>");

		String cond = params.get("condition");
		cond = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, cond, true);
		Logger.detailsFine(INDENT + "If <condition>:    " + cond);

		ArrayList<String> res = Utils.parseCondition(cond);

		ifConditionIsTrue = Utils.checkCondition(res.get(1), res.get(0), res.get(2));
		if (res.size() > 3 && res.get(3).equals("&&") && ifConditionIsTrue)
			ifConditionIsTrue = Utils.checkCondition(res.get(5), res.get(4), res.get(6));
		else if (res.size() > 3 && res.get(3).equals("orequals") && !ifConditionIsTrue)
			ifConditionIsTrue = Utils.checkCondition(res.get(5), res.get(4), res.get(6));
		Logger.detailsFine(INDENT + "If <condition> is: " + ifConditionIsTrue);

		// Stack the current if condition value - to handle ifs inside of ifs
		ifStatements.push(new Boolean(ifConditionIsTrue));

		eventCounterStop();
		Logger.detailsFine("TestDriver.IF() - done");
	}

	/*
	 * Format: "{event":"else"}
	 */

	public void ELSE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.ELSE()");
		// Do nothing - the "else" event will be handled by
		// processTestFileLineByLine()
		Logger.detailsFine("TestDriver.ELSE() - done");
	}
	
	/*
	 * Format: "{event":"elseif"}
	 */

	public void ELSEIF(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.ELSEIF()");
		eventCounterStart("ELSEIF <condition>");

		String cond = params.get("condition");
		cond = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, cond, true);
		Logger.detailsFine(INDENT + "Elseif <condition>:    " + cond);

		ArrayList<String> res = Utils.parseCondition(cond);

		ifConditionIsTrue = Utils.checkCondition(res.get(1), res.get(0), res.get(2));
		Logger.detailsFine(INDENT + "Elseif <condition> is: " + ifConditionIsTrue);

		// Stack the current if condition value - to handle ifs inside of ifs
		ifStatements.push(new Boolean(ifConditionIsTrue));

		eventCounterStop();
		Logger.detailsFine("TestDriver.ELSEIF() - done");
	}

	/*
	 * Format: "{event":"endif"}
	 */

	public void ENDIF(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.ENDIF()");

		// Pop the current if condition value from our stack
		try {
			ifStatements.pop();
		} catch (EmptyStackException ese) {
			Utils.logSevere("Discovered unbalanced if-else-endif - possibly found an \"endif\" event without a corresponding \"if\" event");
			throw ese;
		}

		// Grab the next if condition value off the stack.
		if (!ifStatements.empty()) {
			ifConditionIsTrue = ifStatements.peek().booleanValue();
		}
		elseIfConditionIsTrue = false;

		Logger.detailsFine("TestDriver.ENDIF() - done");
	}

	/**
	 * Process the "invokeJavaMethod" event. To invoke the method, (1) the class
	 * needs to be on the classpath, and (2) the method is either static or the class
	 * must have a nullary constructor. You can optionally put the reurn result of
	 * the method call into a makeVar.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "invokeJavaMethod" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format Examples:
	 * 		{event:invokeJavaMethod, class:java.lang.Integer, method:toOctalString, paramTypes:[int], paramValues:[32],  makeVar:OCTALVAL},
	 * 		{event:invokeJavaMethod, class:java.lang.Integer, method:toOctalString, paramTypes:[int], paramValues:[45]},
	 * 		{event:invokeJavaMethod, class:framework.selenium.TpaeBrowser, method:testMethod1, paramTypes:[String, String], paramValues:[mary, sue],  makeVar:MESSAGE1},
	 * 		{event:invokeJavaMethod, class:framework.selenium.TpaeBrowser, method:testMethod2, paramTypes:[String, int], paramValues:[mary, 12], makeVar:MESSAGE2},
	 * 		{event:invokeJavaMethod, class:framework.selenium.TpaeBrowser, method:testMethod3, paramTypes:[String, boolean], paramValues:[mary, true], makeVar:MESSAGE3},
	 * 		{event:invokeJavaMethod, class:framework.selenium.TpaeBrowser, method:testMethod4, paramTypes:[String, boolean], paramValues:[mary, true], makeVar:MESSAGE4},
	 * 		{event:invokeJavaMethod, class:framework.selenium.TpaeBrowser, method:testMethod5, paramTypes:[], paramValues:[], makeVar:MESSAGE5},
	 * 		{event:invokeJavaMethod, class:framework.selenium.TpaeBrowser, method:main, paramTypes:["String[]"], paramValues:[[]]},
	 * 		{event:invokeJavaMethod, class:framework.selenium.TpaeBrowser, method:testMethod6, paramTypes:[int, "String[]", int], paramValues:[1, [a, b, c], 4], makeVar:MESSAGE6},
	 * 		{event:invokeJavaMethod, class:framework.selenium.TpaeBrowser, method:testMethod7, paramTypes:["int[]"], paramValues:[[1, 2, 3, 4]], makeVar:MESSAGE7},
	 * 		{event:invokeJavaMethod, class:framework.selenium.TpaeBrowser, method:main, paramTypes:["String[]"], paramValues:[[bob,mary,will,ellen]]}
	 *
	 *		where class is the class name you're interested in
	 *			method is the method name inside of the class you want to invoke. 
	 *					This class must be in the run-time classpath and be in the package name format  - e.g. framework.selenium.TpaeBrowser
	 *			paramTypes is the method signature (e.g. int, int[], long, long[], boolean, boolean[], double, double[], string, string[] or
						[] (a null array) - any array type specified needs to be enclosed in quotes e.g. "String[]"
	 *			paramValues are the parameter values (that match the paramTypes - where [] denotes a null array) - any array parameter values 
	 *					need to be enclosed in brackets - e.g. [mary, bob, ellen]
	 *			makeVar is an optional makeVar name to put the result into for use in the bin file 
	 *
	 *	The method needs to either be the main() method, a static method or, if not static, the class needs to have a nullary constructor 
	 *	(a constructor that takes no arguments ). If you call a method that is not a static method, Java will automatically try to create 
	 *	an instance of the class by calling the nullary constructor for the class before invoking the method - thus the need for the nullary 
	 *	constructor.
	 * 
	 */

	/** Primitive type name -> class map. */
	private static final Map<String, Class<?>> PARAMETER_NAME_TYPE_MAP = new HashMap<String, Class<?>>();

	/** Setup the parameter map of allowable parameter types. */
	static {
		PARAMETER_NAME_TYPE_MAP.put("string", String.class);			// e.g. mary
		PARAMETER_NAME_TYPE_MAP.put("string[]", String[].class);		// e.g. "mary, bob, bill"
		PARAMETER_NAME_TYPE_MAP.put("int", int.class);				// e.g. 10
		PARAMETER_NAME_TYPE_MAP.put("int[]", int[].class);			// e.g. "10, 20, 30"
		PARAMETER_NAME_TYPE_MAP.put("boolean", boolean.class);		// e.g. true/false
		PARAMETER_NAME_TYPE_MAP.put("boolean[]", boolean[].class);	// e.g. "true, false, true"
		PARAMETER_NAME_TYPE_MAP.put("double", double.class);			// e.g. 100.26
		PARAMETER_NAME_TYPE_MAP.put("double[]", double[].class);		// e.g. "100.26, 200.45 310.11"
		PARAMETER_NAME_TYPE_MAP.put("long", long.class);				// e.g. 10
		PARAMETER_NAME_TYPE_MAP.put("long[]", long[].class);			// e.g. "10, 20, 30"
	}

	public void INVOKEJAVAMETHOD(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.INVOKEJAVAMETHOD()");
		eventCounterStart("INVOKEJAVAMETHOD");

		//	Get the class name

		String className = params.get("class").trim();
		className = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, className, true);
		Logger.detailsFine(INDENT + "class = " + className);

		//	Get the method name

		String methodName = params.get("method").trim();
		methodName = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, methodName, true);
		Logger.detailsFine(INDENT + "method = " + methodName);

		//	Get the parameter types (for finding the correct method signature in the class)

		String paramTypes = params.get("paramTypes").trim();
		Logger.detailsFine(INDENT + "paramTypes = " + paramTypes);
		JSONArray paramTypesElement = new JSONArray(paramTypes);

		Class<?>[] paramTypesArray = new Class<?>[paramTypesElement.length()];
		for (int i = 0; i < paramTypesElement.length(); i++) {
			String type = paramTypesElement.getString(i).toLowerCase();
			//	If an unsupported parameter type is specified, throw an exception back.
			if(PARAMETER_NAME_TYPE_MAP.get(type) == null) {
				String error = "Unsupported parameter type found: " + type;
				Utils.logSevere(error);
				throw new Exception(error);
			}
			paramTypesArray[i] = PARAMETER_NAME_TYPE_MAP.get(type);
		}

		//	Get the printable method signature - for use in log messages below
		//	Convert something like ["int", "String[]", "boolean"] to (int, String[], boolean)

		String methodSignature = ("(" + paramTypes.substring(1, paramTypes.length()-1) + ")").replaceAll("\"", "");

		//	Get the parameter values (to pass to the method when invoked)

		String paramValues = params.get("paramValues").trim();
		Logger.detailsFine(INDENT + "paramValues = " + paramValues);
		JSONArray paramValuesElement = new JSONArray(paramValues);

		//	If the number of param types do not match the number of param values, throw an exception back

		if(paramValuesElement.length() != paramTypesElement.length()) {
			String error = "Mismatch in number of parameter types(" + paramTypesElement.length() + 
					") versus parameter values (" + paramValuesElement.length() + ")";
			Utils.logSevere(error);
			throw new Exception(error);
		}

		//	Create an Object array to hold the parameter values of the right type. A
		// 	NumberFormatException might get thrown back if we encounter a numeric
		//	parameter that cannot be converted properly. That's ok - the exception
		//	will get thrown back and the test will just	abort. 	

		Object[] paramValuesArray = new Object[paramTypesArray.length];

		//	Now convert our parameters to the right type as expected by the Java method specified

		for (int i = 0; i < paramValuesElement.length(); i++) {
			String temp = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, paramValuesElement.getString(i), true);

			if(paramTypesArray[i] == String.class)
				paramValuesArray[i] = temp;
			else if(paramTypesArray[i] == String[].class) {
				JSONArray arrayElement = new JSONArray(temp);
				String[] stringArray = new String[arrayElement.length()];
				for(int j = 0; j < arrayElement.length(); j++) {
					stringArray[j] =  arrayElement.getString(j);
				}
				paramValuesArray[i] =  stringArray;
			}

			else if(paramTypesArray[i] == int.class)
				paramValuesArray[i] = Integer.parseInt(temp);
			else if(paramTypesArray[i] == int[].class) {
				JSONArray arrayElement = new JSONArray(temp);
				int[] intArray = new int[arrayElement.length()];
				for(int j = 0; j < arrayElement.length(); j++) {
					intArray[j] =  Integer.parseInt(arrayElement.getString(j));
				}
				paramValuesArray[i] =  intArray;
			}

			else if(paramTypesArray[i] == boolean.class)
				paramValuesArray[i] = Boolean.parseBoolean(temp);
			else if(paramTypesArray[i] == boolean[].class) {
				JSONArray arrayElement = new JSONArray(temp);
				boolean[] booleanArray = new boolean[arrayElement.length()];
				for(int j = 0; j < arrayElement.length(); j++) {
					booleanArray[j] = Boolean.parseBoolean(arrayElement.getString(j));
				}
				paramValuesArray[i] = booleanArray;
			}

			else if(paramTypesArray[i] == double.class)
				paramValuesArray[i] = Double.parseDouble(temp);
			else if(paramTypesArray[i] == double[].class) {
				JSONArray arrayElement = new JSONArray(temp);
				double[] doubleArray = new double[arrayElement.length()];
				for(int j = 0; j < arrayElement.length(); j++) {
					doubleArray[j] = Double.parseDouble(arrayElement.getString(j));
				}
				paramValuesArray[i] =  doubleArray;
			}

			else if(paramTypesArray[i] == long.class)
				paramValuesArray[i] = Long.parseLong(temp);
			else if(paramTypesArray[i] == long[].class) {
				JSONArray arrayElement = new JSONArray(temp);
				long[] longArray = new long[arrayElement.length()];
				for(int j = 0; j < arrayElement.length(); j++) {
					longArray[j] = Long.parseLong(arrayElement.getString(j));
				}
				paramValuesArray[i] =  longArray;
			}

			else {
				String error = "Unsupported parameter type: " + paramTypesArray[i];
				Utils.logSevere(error);
				throw new Exception(error);
			}
		}

		//	Check for the optional makeVar 

		String makeVar = params.get("makeVar");
		if(makeVar != null) {
			makeVar = makeVar.trim();
			Logger.detailsFine(INDENT + "makeVar = " + makeVar);
		}

		//	Go invoke the method!

		Object value = null;
		try {
			Logger.detailsFine(INDENT + "Try to invoke " + className + "." + methodName + methodSignature);

			Class<?> c = Class.forName(className);
			Method  method = c.getMethod (methodName,  paramTypesArray);

			//	If the method is "static", just call it directly. Otherwise, we need to
			//	create an instance of the clas before it can be invoked.

			if(Modifier.isStatic(method.getModifiers()))
				value = method.invoke(c, paramValuesArray);
			else
				value = method.invoke(c.newInstance(), paramValuesArray);

			Logger.detailsFine(INDENT + "Value returned from " + methodName + methodSignature + ": " + value);
		} catch(NoClassDefFoundError ncde) {
			Utils.logSevere("Cannot find class in classpath: " + className);
			Utils.logSevere("Re-check classpath and/or class name specified.");
			throw ncde;
		} catch(ClassNotFoundException cnfe) {
			Utils.logSevere("Cannot find class in classpath: " + className);
			Utils.logSevere("Re-check classpath and/or class name specified.");
			throw cnfe;
		} catch(NoSuchMethodException nsme) {
			Utils.logSevere("Cannot find method with parameters/signature indicated: " + methodName + methodSignature);
			throw nsme;
		} catch(InstantiationException ie) {
			Utils.logSevere("Could not instantiate method: " + methodName + methodSignature);
			Utils.logSevere("Make sure the class object (" + className + ") is not an abstract class, an interface, an array class, a primitive type, or void."); 
			Utils.logSevere("Make sure the class object (" + className + ") has a nullary constructor - a constructor with no parameters");
			throw ie;
		} catch(Exception e) {
			//	Throw any other excreption back up
			Utils.logSevere("Exception trying to invoke method " + methodName + methodSignature);
			throw e;
		}

		//	Store the result into our makeVar if one was specified

		if(makeVar != null) {

			if(value == null)
				value = "NULL";

			Logger.detailsFine(INDENT + "Set " + makeVar + " value = \"" + value + "\"");

			// Add our makeVar variable and value key value pair to our "variable" hash
			// table. For variable substitution, we prepend a "$" to the variable name.
			makeVars.put("$" + makeVar, value.toString());
		}

		//	Voila! We're done!

		eventCounterStop();
		Logger.detailsFine("TestDriver.INVOKEJAVAMETHOD() - done");
	}


	/**
	 * Process the "keystroke" event. Calls the appropriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "keystroke" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"keystroke", "id": "m6a7dfd2f_tfrow_[C:3]_txt-tb", "params":[9,"\t",false,false,true]
	 * 		}
	 */

	public void KEYSTROKE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.KEYSTROKE()");
		eventCounterStart("KEYSTROKE");

		String id = params.get("id").trim();
		String paramsVal = params.get("params").trim();

		Logger.detailsFine(INDENT + "id = " + id);
		Logger.detailsFine(INDENT + "params = " + paramsVal);

		// Parse the JSON "params" string to a JSONArray
		JSONArray elements = new JSONArray(paramsVal);

		// Get the needed parameters out of the params array
		int keyCode = elements.getInt(0);
		String value = elements.getString(1); // Don't trim() on purpose.
		boolean ctrlKey = elements.getBoolean(2);
		boolean altKey = elements.getBoolean(3);
		boolean shiftKey = elements.getBoolean(4);

		Logger.detailsFine(INDENT + "keycode = " + keyCode);
		Logger.detailsFine(INDENT + "value = " + value);
		Logger.detailsFine(INDENT + "ctrlKey = " + ctrlKey);
		Logger.detailsFine(INDENT + "altKey = " + altKey);
		Logger.detailsFine(INDENT + "shiftKey = " + shiftKey);

		browser.keystroke(id, keyCode, value, ctrlKey, altKey, shiftKey);

		eventCounterStop();
		Logger.detailsFine("TestDriver.KEYSTROKE() - done");
	}

	/**
	 * Process the "label" event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "label" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: { "event":"label", "name": "myLabel" }
	 */

	public void LABEL(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.LABEL()");
		eventCounterStart("LABEL");

		String label = params.get("label").trim();
		Logger.detailsFine(INDENT + "label = " + label);

		eventCounterStop();
		Logger.detailsFine("TestDriver.LABEL() - done");
	}

	/**
	 * Process the "Login" event. Calls the appropriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "Login" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 * 
	 * 
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"login", "user":"<user>", "pswd":"<pswd>", "language":"<lang>", 
	 * 					"tenantCode":"<tenant code>, "app":"<app id>","url":"<URL>"
	 * 		}
	 * 
	 * Note: "app" is required in mobile
	 */
	public void LOGIN(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.LOGIN()");
		eventCounterStart("LOGIN");

		String lang = "";
		String tenant = "";
		String app = "";
		String url = null;

		String user = params.get("user").trim();
		String pswd = params.get("pswd").trim();

		// Not required/passed-in by mobile
		if (params.get("language") != null)
			lang = params.get("language").trim();
		if (params.get("tenantCode") != null)
			tenant = params.get("tenantCode").trim();
		if (params.get("app") != null)
			app = params.get("app").trim();
		if (params.get("url") != null)
			url = params.get("url").trim();

		user = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, user, true);
		pswd = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, pswd, true);
		lang = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, lang, true);
		tenant = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, tenant, true);
		app = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, app, true);

		Logger.detailsFine(INDENT + "user = " + user);
		Logger.detailsFine(INDENT + "pswd = " + pswd);
		Logger.detailsFine(INDENT + "lang = " + lang);
		Logger.detailsFine(INDENT + "tenant = " + tenant);

		String host = AutomationUtility.getProperty("uitest.defaultURL");
		String backupHost = AutomationUtility.getProperty("uitest.backupURL");

		//	If we're doing a log in and we're already on the login page (new user creation was done),
		//	do a "fake" log out before we proceed. This should be for Tpae only.
		int currentBrowserInstance = getCurrentBrowserIndex();
		if(isLoggedInForInstance(currentBrowserInstance) && browser.onLogInPage()) {
			setLoggedInForInstance(currentBrowserInstance, false);
		} else if(isLoggedInForInstance(currentBrowserInstance)) {
			browser.logout();	// this will also close any open dialogs
			setLoggedInForInstance(currentBrowserInstance, false);
		}

		// Log in as specified user and record the app we're in. At this point we're either on the
		// login page, or a new browser instance has been created for another login.

		if (!app.equals("")) {
			browser.waitForWaitlayer();
			browser.logInToApp(user, pswd, host, backupHost, tenant, lang, app);
			setAppForInstance(currentBrowserInstance, app);
		}
		//	No app was specified and we're in Tpae - log in to the Start Center
		else if(browser instanceof TpaeBrowser) {
			browser.waitForWaitlayer();
			browser.logInAs(user, pswd, host, backupHost, tenant, lang);
			setAppForInstance(currentBrowserInstance, "startcntr");
		} 
		
		setLoggedInForInstance(currentBrowserInstance, true);
		makeVars.put("$BROWSER_INSTANCE", new Integer(currentBrowserInstance).toString());

		eventCounterStop();
		Logger.detailsFine("TestDriver.LOGIN() - done");
	}

	/**
	 * Process the "LoginNewInstance" event. Calls the appropriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "Login" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 * 
	 * 
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"loginnewinstance", "user":"<user>", "pswd":"<pswd>", "language":"<lang>", 
	 * 					"tenantCode":"<tenant code>, "app":"<app id>","url":"<URL>","driver":"<driver>"
	 * 		}
	 * 
	 * Note: "app" is required in mobile
	 */
	public void LOGINNEWINSTANCE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.LOGINNEWINSTANCE()");
		int totalBrowserInstances = getTotalBrowserInstances();

		// If we are already max'ed out on the allowable number of browser instances, just fail the test.

		if (totalBrowserInstances == MAX_DRIVERS) {
			browser.testFail("Attempt to exceed the allowable number of browser instances: " + MAX_DRIVERS);
		}

		//	Minimize the current browser instance
		browser.getDriver().manage().window().setSize(new Dimension(defaultWindowSize.getWidth(), 0));

		totalBrowserInstances = incrementTotalBrowserInstances();

		Logger.detailsFine("TestDriver.LOGINNEWINSTANCE() - creating browser instance " + totalBrowserInstances);
		
		//	Create a new instance of browser
		Browser newBrowser = getBrowser(totalBrowserInstances, browserClass);
		
		setBrowserInstance(totalBrowserInstances, newBrowser);
		setLoggedInForInstance(totalBrowserInstances, false);
		setCurrentBrowserIndex(totalBrowserInstances);
		
		// Nudge the new browser window 20 px to the right of the last browser window created.
		newBrowser.getDriver().manage().window().setPosition(new Point(((20 * (totalBrowserInstances - 1)) + defaultWindowPosition.getX()), defaultWindowPosition.getY()));

		// Log in with the specified data

		LOGIN(newBrowser, args,	params,	makeVars, dataFileVars);

		Logger.detailsFine("TestDriver.LOGINNEWINSTANCE() - done");
	}


	/**
	 * Process the "makeVariable" event. Calls the appropriate Browser method
	 * that corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "makeVariable" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"makeVariable", "id": "m6a7dfd2f_tfrow_[C:3]_txt-tb", "params":["WONUM"] }
	 * 
	 * or, for generating random integers and strings, somthing like this
	 * 
	 * 	{"event":"makeVariable","random":"int:2", "params":["LOC"]}
	 * 	{"event":"makeVariable","random":"string:8", "params":["WONUM"]},
	 * 
	 * or, set a variable to a static string
	 * 
	 * 	{"event":"makeVariable","static":"mxe.some.prop", "params":["PROPVAR"]}
	 * 
	 * or, set a variable to the result of an SQL query
	 * 
	 * 	{"event":"makeVariable","sql":"select count(*) from {$TABLE}", "params":["SQL_VAR"]}
	 * 
	 * or, check if an element exists or not (returns true or false)
	 * 
	 * {"event":"makeVariable","elementExists":"Maximo_Asset_Management_(SaaS)", "params":["isSaaS"]},
	 * 
	 * or, check if a textbox is read only or editable (returns true or false)
	 * 
	 * {"event":"makeVariable","isReadOnlyTextbox":"m99cbe779-tb", "params":["isReadOnlyTextbox"]},
	 * 
	 * or, for generating a date/time
	 * 		Where "format" can be date, dateAndTime, or time:
	 * 		{ 
	 * 			"event":"makevariable", "id":"m73f28d7-tb",
	 * 			"date":"[{"date":"currentTime", "format":"time"}],
	 * 			"params":["date1"] 
	 * 		} 
	 * 		
	 * 		OR "date":[{"date":"today", "format":"date"}]} 
	 * 		OR "date":[{"date":"timeBeforeToday", "years":1, "months":1, "days":1, "hours":1, "minutes":1, "format":"dateAndTime"}] 
	 * 		OR "date":[{"date":"timeFromToday", "years":1, "months":1, "days":1, "hours":1, "minutes":1, "format":"date"}] 
	 * 		OR "date":[{"date":"daysBeforeToday", "days":1, "format":"date"}]} 
	 * 		OR "date":[{"date":"daysFromToday", "days":1, "format":"date"}]}
	 * 
	 * or,  for extracting a substring
	 * {"event":"makeVariable","string":"string that we want to grab substring from","substring":[7],"params":["substring1"]},
	 * where "substring" can be changed to "delimiters":
	 * {"event":"makeVariable", "string":"PM pmnum created work order 1036.","delimiters":["work order","."], "params":["delimiter1"]}
	 * 
	 * or, for saving the result of a mathematic operation
	 * {"event":"makeVariable","result"{i}+1","params":["variableName"]} 
	 * 
	 */

	public void MAKEVARIABLE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.MAKEVARIABLE()");
		eventCounterStart("MAKEVARIABLE");

		String value = null;
		String query = null;

		if (params.get("id") != null) {
			String id = params.get("id").trim();
			id = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, id, true);
			Logger.detailsFine(INDENT + "id = " + id);

			// Get the appropriate value from the screen
			browser.waitForWaitlayer();

			WebElement element = browser.getElement(id);
			if (!id.contains("cb_img") && !id.contains("checkbox-cb"))
			{
				value = element.getText();
				if(value == null || value.equals("")) {
					value = element.getAttribute("value");
					if (value == null || value.equals(""))
						value = element.getAttribute("innerHTML");
				}
				if (browser.getAttribute(element, id, "className").indexOf("tc") >= 0) {
					value = browser.getAttribute(element, id, "innerText");
					if (value == "")
						value = element.getText();
				}
			}
			else
			{
				String src = element.getAttribute("src");
				if (src.contains("cb_checked"))
					value = "true";
				else
					value = "false";
			}
			Logger.detailsFine(INDENT + "value = " + value);

		} else if (params.get("random") != null) {
			String randomType = params.get("random").trim();
			Logger.detailsFine(INDENT + "random = " + randomType);
			value = Randomizer.getRamdomValue(randomType);
		} else if (params.get("static") != null) {
			value = params.get("static").trim();
			value = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, value, true);
			Logger.detailsFine(INDENT + "static = " + value);
		} else if (params.get("sql") != null) {
			query = params.get("sql").trim();// get the query
			query = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, query, true);
			if (!query.contains("update") && !query.contains("insert"))
				value = AutomationUtility.getSQLValue(query);// set 'value' to the result of the query
			else
				value = AutomationUtility.runSQL(query);
			Logger.detailsFine(INDENT + "sql = " + value);
		} else if (params.get("isReadOnlyTextbox") != null) {
			String id = params.get("isReadOnlyTextbox").trim();
			Logger.detailsFine(INDENT + "id = " + id);
			browser.waitForWaitlayer();
			boolean isRO = browser.isReadOnlyTextbox(id);
			value = String.valueOf(isRO);
		} else if (params.get("elementExists") != null) {
			String id = params.get("elementExists").trim();
			id = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, id, true);
			Logger.detailsFine(INDENT + "id = " + id);
			browser.waitForWaitlayer();
			boolean elementExists = browser.elementExists(id);
			value = String.valueOf(elementExists);
		} else if (params.get("date") != null) {
			String id = params.get("date").trim();
			Logger.detailsFine(INDENT + "id = " + id);
			value = getDateTime(browser, args, params, makeVars, dataFileVars, "date");
		} else if (params.get("substring") !=null) {
			String id = params.get("substring").trim();
			Logger.detailsFine(INDENT + "id = " + id);
			JSONArray substringElements = new JSONArray(id);
			String message = params.get("string");
			message = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, message, true);
			int start;
			int end;
			// first determine if we have 1 or 2 substring params
			int length = substringElements.length();
			if (length == 1) {
				// then there is just a start
				start = substringElements.getInt(0);
				message = message.substring(start).trim();
			} else {
				start = substringElements.getInt(0);
				end = substringElements.getInt(1);
				message = message.substring(start, end).trim();
			}
			value = message;
		} else if (params.get("delimiters") !=null) {
			String id = params.get("delimiters").trim();
			Logger.detailsFine(INDENT + "id = " + id);
			String message = params.get("string");
			message = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, message, true);
			JSONArray delimiterElements = new JSONArray(id);
			int length = delimiterElements.getString(0).length();
			message = message.substring(
					message.indexOf(delimiterElements.getString(0)) + length)
					.trim();
			message = message.substring(0,
					message.indexOf(delimiterElements.getString(1))).trim();
			value = message;
		} else if (params.get("result") != null) {
			String cond = params.get("result").trim();
			cond = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, cond, true);
			ArrayList<String> res = Utils.parseMathCondition(cond);
			int arg1 = Integer.parseInt(res.get(0));
			int arg2 = Integer.parseInt(res.get(2));
			int myvalue = Utils.getResult(res.get(1), arg1, arg2);
			value = Integer.toString(myvalue);
		}

		String paramsVal = params.get("params").trim();
		Logger.detailsFine(INDENT + "params = " + paramsVal);

		// Parse the JSON "params" string to a JSONArray
		JSONArray elements = new JSONArray(paramsVal);

		// Get the needed parameters out of the params array
		String varName = elements.getString(0).trim();
		Logger.detailsFine(INDENT + "varName = " + varName);
		Logger.detailsFine(INDENT + "value = " + value);

		// Add our variable and value key value pair to our "variable" hash
		// table. For variable substitution, we prepend a "$" to the variable name.
		makeVars.put("$" + varName, value);

		eventCounterStop();
		Logger.detailsFine("TestDriver.MAKEVARIABLE() - done");
	}

	/**
	 * Process the "reLogin" event. Calls the appropriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "reLogin" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 * 
	 * 
	 */
	/*
	 * 	Format: 
	 * 		{ 
	 * 			"event":"relogin", "user":"<user>", "pswd":"<pswd>",
	 * 			"language":"<lang>", "tenantCode":"<tenant code>, "app":"<app id>"
	 * 		}
	 */
	public void RELOGIN(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.RELOGIN()");

		//	If not on the login page, then logout. In mobile, the test better be on a screen
		//	that has access to logout - not all screens do! Otherwise, an exception will
		// 	get thrown back to the driver and the test will fail.

		if(!browser.onLogInPage()) {
			browser.logout();	// this will also close any open dialogs
		}

		// Log back in with the specified data

		setLoggedInForInstance(getCurrentBrowserIndex(), false);
		LOGIN(browser, args, params, makeVars, dataFileVars);

		Logger.detailsFine("TestDriver.RELOGIN() - done");
	}

	/**
	 * Process the "screenshot" event. Calls the appropriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "screenshot" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: { "event":"screenshot" }
	 */

	public void SCREENSHOT(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {
		if ("true".equalsIgnoreCase(takeScreenshots)) {
			Logger.detailsFine("TestDriver.SCREENSHOT()");
			eventCounterStart("SCREENSHOT");

			Logger.getScreenshot(getCurrentBrowserIndex());

			eventCounterStop();
			Logger.detailsFine("TestDriver.SCREENSHOT() - done");
		}
	}

	/**
	 * Process the "select checkbox" event. Calls the appropriate Browser method
	 * that corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            true or false boolean that represents the checkbox state
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * 	Format: 
	 * 		{ 
	 * 			"event":"selectCheckbox", "id": "me1e9daa8-cb", "params":["true"], "eventType":"click" 
	 * 		}
	 */

	public void SELECTCHECKBOX(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.SELECTCHECKBOX()");
		eventCounterStart("SELECTCHECKBOX");

		String id = params.get("id");
		id = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, id, true);
		String value =  params.get("params").trim();
		value = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, value, true);

		Logger.detailsFine(INDENT + "id = " + id);
		String checkboxID = id;

		JSONArray elements = new JSONArray(value);
		boolean setState = elements.getBoolean(0);

		if (setState) {
			if (!browser.isChecked(checkboxID))
				browser.click(id);
		} else {
			if (browser.isChecked(checkboxID))
				browser.click(id);
		}

		eventCounterStop();
		Logger.detailsFine("TestDriver.SELECTCHECKBOX() - done");
	}
	/**
	 * Process the "select" event. Calls the appropriate Browser method
	 * that corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            true or false boolean that represents the checkbox state
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * 	Format: 
	 * 		{ 
	 * 			"event":"select", "id": "me1e9daa8-cb", "params":["WAMTL"], "eventType":"click" 
	 * 		}
	 */

	public void SELECT(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.SELECT()");
		eventCounterStart("SELECT");

		String id = params.get("id");
		id = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, id, true);
		String value = params.get("params").trim();
		value =  value.substring(2,value.length()-2);
		value = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, value, true);

		Logger.detailsFine(INDENT + "id = " + id);
		
		WebElement mySelectElm = browser.getDriver().findElement(By.id(id)); 
		Select mySelect= new Select(mySelectElm);
		mySelect.selectByValue(value);

		//JSONArray elements = new JSONArray(value);

		eventCounterStop();
		Logger.detailsFine("TestDriver.SELECT() - done");
	}

	/**
	 * Process the "sleep" event. Calls the aprpopriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "sleep" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: { "event":"sleep", "params":[2] }
	 */

	public void SLEEP(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.SLEEP()");
		eventCounterStart("SLEEP");

		String paramsVal = params.get("params").trim();

		Logger.detailsFine(INDENT + "params = " + paramsVal);

		// Parse the JSON "params" string to a JSONArray
		JSONArray elements = new JSONArray(paramsVal);

		// Get the one and only parameter out of the params array - the number
		// of seconds to sleep
		int seconds = elements.getInt(0);
		Logger.detailsFine(INDENT + "seconds = " + seconds);

		browser.sleep(seconds);

		eventCounterStop();
		Logger.detailsFine("TestDriver.SLEEP() - done");
	}

	/**
	 * Process the "startTestStep" event.
	 * 
	 * @param browser
	 *            the current Browser class instancee 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            true or false boolean that represents the checkbox state
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: { "event":"startTestStep", "name":"Create WONum" }
	 */

	public void STARTTESTSTEP(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.STARTTESTSTEP()");
		eventCounterStart("STARTTESTSTEP");

		String name = params.get("name");
		Logger.detailsFine(INDENT + "name = " + name);
		name = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, name, true);

		Logger.startTestStep(name);

		eventCounterStop();
		Logger.detailsFine("TestDriver.STARTTESTSTEP() - done");
	}

	/***
	 * Switches to a window that was just opened.  Remember to save the original window handle before calling this.
	 * Then when done using the new window you can use that original window handle to return to the original window.
	 * When done with new window, close it:
	 * browser.getDriver().close();
	 * 

	 * 
	 * Format: { "event":"switchtoNewInstance" }
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "switchInstance" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	public void SWITCHTONEWINSTANCE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars) throws Exception {
		
		// Store the current window handle:
		winHandleBefore = browser.getDriver().getWindowHandle();
		
		// Switch to new window opened
		for(String winHandle : browser.getDriver().getWindowHandles()){
			browser.getDriver().switchTo().window(winHandle);
		}
	}
	
	/***
	 * Switches to a specific window.
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "switchInstance" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 * Format: { "event":"returnToOriginalInstance"}
	 */
	public void RETURNTOORIGINALINSTANCE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars) throws Exception {

		browser.getDriver().switchTo().window(winHandleBefore);
	}
	
	/**
	 * Process the "switchInstance" event. Calls the appropriate Browser method
	 * that corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "switchInstance" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: { "event":"switchInstance", "instance":2 }
	 */

	public void SWITCHINSTANCE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.SWITCHINSTANCE()");
		eventCounterStart("SWITCHINSTANCE");

		String instance = params.get("instance").trim();
		instance = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, instance, true);

		Logger.detailsFine(INDENT + "instance = " + instance);

		//	Special case for switching between tabs if BIRT reports were generated
		//	in different tabs as opposed to a separate browser instance. If we have
		//	more than 1 tab displayed, assume that the SwitchInstance applies to this
		//	browser instance and it means to "SwitchTabs" instead.
		ArrayList<String> tabs = new ArrayList<String> (browser.getDriver().getWindowHandles());
		if(instance.equals("1") && tabs.size() > 1) {
			//	Close the tab the BIRT report is displayed in
			browser.getDriver().switchTo().window(tabs.get(tabs.size() - 1));
			browser.getDriver().close();
			//	Switch control back to the tab that generated the report
			browser.getDriver().switchTo().window(tabs.get(Integer.parseInt(instance) - 1));
			browser.sleep(1);
		}
		else {

			//	Minimize the current browser instance
			browser.getDriver().manage().window().setSize(new Dimension(defaultWindowSize.getWidth(), 0));

			// Switch to the correct browser instance and maximize it

			setCurrentBrowserIndex(new Integer(instance).intValue());
			browser = getBrowserInstance(getCurrentBrowserIndex());
			browser.getDriver().manage().window().setSize(defaultWindowSize);

			makeVars.put("$BROWSER_INSTANCE", instance);
		}

		eventCounterStop();
		Logger.detailsFine("TestDriver.SWITCHINSTANCE() - done");
	}
		
	/**
	 * Process the "typeover" event. Calls the appropriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "typeover" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"typeover", "id":"m72b67f92-tb", "params":["something"]
	 * 		}
	 * 
	 * or for generating a random string
	 * 
	 * 		{ 
	 * 			"event":"typeover", "id":"m73f28d7-tb", "params":["random:string:8"] 
	 * 		}
	 * or for generating a date/time
	 * 		Where "format" can be date, dateAndTime, or time.
	 * 		For all of the "date" param options, see MAKEVARIABLE comments
	 * 
	 * 		{ 
	 * 			"event":"typeover", "id":"m73f28d7-tb", "params":"date", "date":[{"date":"timeBeforeToday", "years":1, "months":1, "days":1, "hours":1, "minutes":1, "format":"dateAndTime"}] 
	 * 		} 
	 * 
	 * 
	 */
	public void TYPEOVER(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.TYPEOVER()");
		eventCounterStart("TYPEOVER");

		String id = params.get("id");
		id = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, id, true);
		String paramsVal = params.get("params").trim();
		String typeOver;

		//see if we have a date. date is the only typeover without JSONArray in params.
		if (paramsVal.equals("date")){
			typeOver = getDateTime(browser, args, params, makeVars, dataFileVars, "date");
		} else {
			Logger.detailsFine(INDENT + "id = " + id);
			Logger.detailsFine(INDENT + "params = " + paramsVal);

			JSONArray elements = new JSONArray(paramsVal);
			typeOver = elements.getString(0);

			// See if we have a "random:" string. Something like - "random:string:8" or "random:int:3"

			if (typeOver.startsWith("random:")) {
				String randomType = typeOver.substring(typeOver.indexOf(':') + 1);
				Logger.detailsFine("	random = " + randomType);
				typeOver = Randomizer.getRamdomValue(randomType);
			} else {
				//	Otherwise it is a static string of some sort. But, check for variable
				//	substitution. Don't trim() on purpose.
				typeOver = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, typeOver, true);
			}
		}
		Logger.detailsFine(INDENT + "typeOver = " + typeOver);

		browser.typeOver(id, typeOver);

		eventCounterStop();
		Logger.detailsFine("TestDriver.TYPEOVER() - done");
	}
	
	/**
	 * Process the "doubleClick" event. Calls the appropriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "click" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"doubleClick", "id": "m6a7dfd2f_tdrow_[C:1]_ttxt-lb[R:2]"
	 * 		}
	 */
	public void DOUBLECLICK(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.DOUBLECLICK()");
		eventCounterStart("DOUBLECLICK");

		String idOrXpath = params.get("id").trim();
		idOrXpath = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, idOrXpath, true);
		if (idOrXpath.length() == 0) {
			idOrXpath = params.get("xpath").trim();
		}
		Logger.detailsFine(INDENT + "id = " + idOrXpath);

		browser.doubleClick(idOrXpath);

		eventCounterStop();
		Logger.detailsFine("TestDriver.DOUBLECLICK() - done");
	}

	/**
	 * Get a date/time value
	 * 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the event calling this method
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @param key
	 *            the key to look for values from
	 * @throws Exception
	 *             if the event being processed throws an exception
	 * 
	 * @return returns the String date/time value
	 * @throws JSONException
	 */
	public String getDateTime(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars,
			String key) throws JSONException {

		String paramsVal = params.get(key).trim();
		JSONArray elements = new JSONArray(paramsVal);
		String dateTime = "";
		JSONObject element = elements.getJSONObject(0);
		String dateType = element.getString("date"); // e.g. timeBeforeToday
		String format = checkForVariableSubstitution(browser, args, makeVars,
				dataFileVars, element.getString("format"), true);
		int years;
		int months;
		int days;
		int hours;
		int minutes;

		if (dateType.equals("timeBeforeToday")) {
			// "params":[{"date":"timeBeforeToday", "years":1, "months":1,
			// "days":1, "hours":1, "minutes":1, "format":"dateAndTime"}]
			years = Integer.parseInt(checkForVariableSubstitution(browser, args,
					makeVars, dataFileVars, element.getString("years"), true));
			months = Integer.parseInt(checkForVariableSubstitution(browser, args,
					makeVars, dataFileVars, element.getString("months"), true));
			days = Integer.parseInt(checkForVariableSubstitution(browser, args,
					makeVars, dataFileVars, element.getString("days"), true));
			hours = Integer.parseInt(checkForVariableSubstitution(browser, args,
					makeVars, dataFileVars, element.getString("hours"), true));
			minutes = Integer.parseInt(checkForVariableSubstitution(browser, args, makeVars,
					dataFileVars, element.getString("minutes"), true));
			dateTime = DateUtil.getTimeBeforeToday(years, months, days, hours, minutes).formatForTests(format);
		} else if (dateType.equals("timeFromToday")) {
			years = Integer.parseInt(checkForVariableSubstitution(browser, args,
					makeVars, dataFileVars, element.getString("years"), true));
			months = Integer.parseInt(checkForVariableSubstitution(browser, args,
					makeVars, dataFileVars, element.getString("months"), true));
			days = Integer.parseInt(checkForVariableSubstitution(browser, args,
					makeVars, dataFileVars, element.getString("days"), true));
			hours = Integer.parseInt(checkForVariableSubstitution(browser, args,
					makeVars, dataFileVars, element.getString("hours"), true));
			minutes = Integer.parseInt(checkForVariableSubstitution(browser, args, makeVars,
					dataFileVars, element.getString("minutes"), true));
			dateTime = DateUtil.getTimeFromToday(years, months, days, hours, minutes).formatForTests(format);
		} else if (dateType.equals("daysBeforeToday")) {
			days = Integer.parseInt(checkForVariableSubstitution(browser, args,
					makeVars, dataFileVars, element.getString("days"), true));
			dateTime = DateUtil.getDaysBeforeToday(days).formatForTests(format);
		} else if (dateType.equals("daysFromToday")) {
			days = Integer.parseInt(checkForVariableSubstitution(browser, args,
					makeVars, dataFileVars, element.getString("days"), true));
			dateTime = DateUtil.getDaysFromToday(days).formatForTests(format);
		}
		// returns either the current date or the current time depending on
		// format provided
		else if (dateType.equals("currentTime") || dateType.equals("today")) {
			dateTime = DateUtil.getToday().formatForTests(format);
		}

		return dateTime;
	}


	/**
	 * Process the "while" event. These can also have embedded "while" events.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "while" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{"event":"while", "condition":"<cond>"}
	 * 			 ... 
	 * 		{"event":"endwhile">
	 * 
	 * where cond looks similar to: ${ARG} == "SomeString" or ${ARG} < 4 or {$ARG1} != {$ARG2}
	 * 
	 * using ==, !=, contains, startswith, endswith for strings and ==, !=, <, <=, >, >= for ints/doubles
	 */


	boolean gotoEndWhile = false; // will become true when the while condition returns false
	Stack<Integer> whileStatements = new Stack<Integer>(); // a stack of while interaction indexes for embedded while's
	int ignoreWhileCnt = 0; // when we need to ignore embedded while interactions

	public void WHILE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		boolean whileConditionIsTrue = false;
		boolean hasCounter = false;
		boolean loopConditionIsTrue = true;
		loopCntr = null;
		if (breakLoop)
		{
			whileConditionIsTrue = true;
			gotoEndWhile = true;
		}
		int startCnt = 0;
		int endCnt = 0;
		int curVal = 0;

		Logger.detailsFine("TestDriver.WHILE()");
		eventCounterStart("WHILE <condition>");

		String paramsVal = null;
		if (params.containsKey("params"))
			paramsVal = params.get("params").trim();
		if (paramsVal != null)
		{	
			JSONArray elements = new JSONArray(paramsVal);
			loopCntr = elements.getString(0); // e.g. loopCntr
			startCnt = new Integer(checkForVariableSubstitution(browser, args, makeVars,
					dataFileVars, elements.getString(1), true)).intValue();
			endCnt = new Integer(checkForVariableSubstitution(browser, args, makeVars,
					dataFileVars, elements.getString(2), true)).intValue();
			curVal = startCnt;
			if (makeVars.get("$" + loopCntr) == null) {
				makeVars.put("$" + loopCntr, new Integer(startCnt).toString());
			} else {
				curVal = new Integer(makeVars.get("$" + loopCntr)).intValue() + 1;
				makeVars.put("$" + loopCntr, new Integer(curVal).toString());
			}
			hasCounter = true;
		}
		
		String cond = params.get("condition");
		cond = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, cond, true);
		Logger.detailsFine(INDENT + "While <condition>:    " + cond);

		ArrayList<String> res = Utils.parseCondition(cond);

		// Check the loop condition
		if (!hasCounter && !breakLoop)
			whileConditionIsTrue = Utils.checkCondition(res.get(1), res.get(0), res.get(2));
		else if (!breakLoop)
		{
			loopConditionIsTrue = (curVal <= endCnt) ? true : false; // if true, continue looping
			whileConditionIsTrue = Utils.checkCondition(res.get(1), res.get(0), res.get(2));
		}
		Logger.detailsFine(INDENT + "While <condition> is: " + whileConditionIsTrue);

		if (!whileConditionIsTrue && loopConditionIsTrue && !breakLoop) {
			// If we have previously saved this while loop location, pop it from
			// the stack because we're done with it
			gotoEndWhile = true; // set to false in driver when we reach the endwhile statement
			if (!whileStatements.isEmpty()) {
				int loc = whileStatements.peek().intValue();
				if (loc == currentInteraction.peek().intValue()) {
					whileStatements.pop();
				}
			if (hasCounter)
				makeVars.remove("$" + loopCntr);
			}
		}
		else if (!loopConditionIsTrue && !breakLoop) {
			gotoEndWhile = true; // set to false in driver when we reach the endwhile statement
			if (!whileStatements.isEmpty()) {
				browser.testFail("While loop reached the maximum count of "+endCnt + " and the condition was never met");
				int loc = whileStatements.peek().intValue();
				if (loc == currentInteraction.peek().intValue()) {
					whileStatements.pop();
				}
			if (hasCounter)
				makeVars.remove("$" + loopCntr);
			}
		} else {
			// Save the location of the while loop so that when we hit the
			// "endwhile" event we can loop back to the beginning of the while loop
			if (!whileStatements.isEmpty()) {
				int loc = whileStatements.peek().intValue();
				if (loc != currentInteraction.peek().intValue()) {
					whileStatements.push(currentInteraction.peek());
				}
			} else {
				whileStatements.push(currentInteraction.peek());
			}
		}

		eventCounterStop();
		Logger.detailsFine("TestDriver.WHILE() - done");
	}


	/*
	 * Format: "{event":"endwhile"}
	 */

	public void ENDWHILE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.ENDWHILE()");

		// Go back to the beginning of the while loop
		try {
			currentInteraction.pop();
			currentInteraction.push(whileStatements.peek());
		} catch (EmptyStackException ese) {
			Utils.logSevere("Discovered unbalanced while-endwhile - possibly found an \"endwhile\" event without a corresponding \"while\" event");
			throw ese;
		}

		Logger.detailsFine("TestDriver.ENDWHILE() - done");
	}

	/*
	 * Format: {"event":"breakpoint"}
	 */
	public void BREAKPOINT(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars) {

		Logger.detailsFine("TestDriver.BREAKPOINT()");

		//	Set your breakpoint on the line below. Once the breakpoint is hit in the debugger, every time
		//	you click "resume" it will stop here after the driver executes the next interaction/event. In
		//	this way you can easily single step thru each interaction.
		this.breakpointWasCalled = true;	// <----- set Eclipse breakpoint here

		Logger.detailsFine("TestDriver.BREAKPOINT() - done");
	}
	
	/**
	 * Process the "mouseover" event. Calls the appropriate Browser method that
	 * corresponds to this event.
	 * 
	 * @param browser
	 *            the current Browser class instance 
	 * @param args
	 *            a hash table of arguments that might have been passed into
	 *            this bin file (used for callouts)
	 * @param params
	 *            a hash table of the JSON key/value parameters associated with
	 *            the "click" event
	 * @param makeVars
	 *            a hash table of any makeVars created so far in this bin file
	 *            execution
	 * @param dataFileVars
	 *            a DataFile object that contains all the input data file
	 *            key/value pairs
	 * @throws Exception
	 *             if the event being processed throws an exception
	 */
	/*
	 * Format: 
	 * 		{ 
	 * 			"event":"mouseover", "id": "m6a7dfd2f_tdrow_[C:1]_ttxt-lb[R:2]"
	 * 		}
	 */
	public void MOUSEOVER(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars) throws Exception {

		Logger.detailsFine("TestDriver.MOUSEOVER()");

		String idOrXpath = params.get("id").trim();
		idOrXpath = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, idOrXpath, true);
		if (idOrXpath.length() == 0) {
			idOrXpath = params.get("xpath").trim();
			idOrXpath = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, idOrXpath, true);
		}
		Logger.detailsFine(INDENT + "id = " + idOrXpath);

		//browser.click(idOrXpath);
		browser.mouesover(idOrXpath);
			
		Logger.detailsFine("TestDriver.MOUSEOVER() - done");
	}
	
	/*
	 * Format: "{event":"calloutReturn","return":"$varname"}
	 */

	public void CALLOUTRETURNVALUE(Browser browser, Hashtable<String, String> args,
			Hashtable<String, String> params,
			Hashtable<String, String> makeVars, DataFile dataFileVars)
					throws Exception {

		Logger.detailsFine("TestDriver.CALLOUTRETURNVALUE()");

		String returnValue = params.get("returnValue").trim();
		returnValue = checkForVariableSubstitution(browser, args, makeVars, dataFileVars, returnValue, true);
		calloutReturnValue = returnValue;

		Logger.detailsFine("TestDriver.CALLOUTRETURNVALUE() - done");
	}


	//	Track performance data for singleton UI events only (ie. not CALLOUT, not BREAKPOINT, etc.)

	private long xxstartTime = 0;			//	for the current running event
	private String xxeventRunning = null;	// 	the current running event
	//	Hashtable of event counters
	//		key = the event name
	//		value = vector; 0 = event count, 1 = total execution time for all events of this key name
	private Hashtable<String, Vector<Long>> xxeventCounter = new Hashtable<String, Vector<Long>>();

	public void eventCounterStart(String event) {
		Vector<Long> v = xxeventCounter.get(event);
		if(v == null) {
			v = new Vector<Long>();
			v.add((long)1);	//	event counter
			v.add((long)0);	// 	total elapsed time in event
			xxeventCounter.put(event, v);
		}
		else {
			v.set(0, v.elementAt(0) + 1);	//	increment event counter
		}

		xxeventRunning = event;
		xxstartTime = System.currentTimeMillis();
	}

	public void eventCounterStop() {
		long xxelapsedTime = System.currentTimeMillis() - xxstartTime;
		Vector<Long> v = xxeventCounter.get(xxeventRunning);
		v.set(1, v.elementAt(1) + xxelapsedTime);	//	increment total elapsed time in event
	}

	//	Add performance data to the HTML log
	private void logPerformanceData(Browser browser) {
		Logger.detailsFine("TestDriver.logPerformanceData()");

		//	Log any performance data collected by Browser
		browser.logPerformanceData();

		//	Log a sorted list of event data (times called, milliseconds per call)
		Logger.detailsFine("TestDriver.logPerformanceData() - Logging Driver Event Performance Metrics:");
		List<String> keys = new ArrayList<String>(xxeventCounter.keySet());
		Collections.sort(keys);
		for (String key : keys) {
			Vector<Long> v =xxeventCounter.get(key);
			if(key.equals("RELOGIN") || key.equals("LOGINNEWINSTANCE"))
				Logger.detailsFine(INDENT + key + " called " + v.get(0) + (v.get(0) == 1 ? " time. " : " times. ") + "See LOGIN metric for average milliseconds per call");
			else 
				Logger.detailsFine(INDENT + key + " called " + v.get(0) + (v.get(0) == 1 ? " time " : " times ") + "averaging " + v.get(1)/v.get(0) + " ms per call (" + (v.get(1)/1000) + " seconds)");
		}

		Logger.detailsFine("TestDriver.logPerformanceData() - done");
	}

	/*
	 * @param rootFolder a path to the root folder to start the search from
	 * @param testTask the TestTask object for the bin file test (just for logging purposes)
	 */
	public void inputFileSearch(JSONObject binConfig, String rootFolder, TestTask testTask) throws SQLException, JSONException  {
		Logger.detailsFine("DataFile.inputFileSearch(" + rootFolder + ")");
		
		PropsFileSearch propsFileSearch = new PropsFileSearch(uitestRootFolder, testTask);
		Search search = new Search(uitestRootFolder);
		
		//	Go search for our files to run
		String inputFileBaseName = null;
		String inputFilePath = null;
		int filesNotFound = 0;
		do {
			inputFileBaseName = getNextInputFileName(binConfig, INPUT_FILE_BASE_NAME_PROPERTY);
			if(inputFileBaseName != null) {
				try {
					inputFilePath = search.getFilePath(PropsFileSearch.BIN_FILE_DIR_NAME_PROPERTY,
							PropsFileSearch.BIN_FILE_DIR_NAME_PROPERTY_DEFAULT_VALUE,
							inputFileBaseName);
 				} catch (FileNotFoundException e) {
					// Message already logged from getFilePath()
					filesNotFound++;
					search.setErrorHappened();
				} catch (Exception e) {
					// Message already logged from  isTestFeatureInFeatureToggleList()
					search.setErrorHappened();
				}
			}
		}
		while(inputFileBaseName != null);
		
		//	Log the matching files we found - this should be in the same order that we process them
		Iterator<String> keyset = propsFileSearch.getFileList();
		while(keyset.hasNext()){
			Utils.logInfoInColor(propsFileSearch.BLUE, "Found input file: " + keyset.next());
		}
		
		//	Summarize the number of bin test files we could not find
		if(filesNotFound > 0) {
			Utils.logSevere("A total of " + filesNotFound + " input file(s) could not be found, but were specified.");
			testTask.setStatus(ITestResult.FAILURE);
		}
		
		Logger.detailsFine("DataFile.inputFileSearch(" + rootFolder + ") - done");
	}
	
	private int inputNumber = 0; // the dataInputFile property suffix (e.g. dataInputFile-1). This
	// keeps track of the last input file found 
	
	public static int NUMBER_OF_POSSIBLE_INPUT_FILES = 5; 	// the maximum number of test files we'll look for
	
	/**
	 * A generic method for finding the next data input file name 
	 * It will search thru up to 5 property names (e.g.
	 * dataInputFile, dataInputFile-1, dataInputFile-2, ...
	 * dataInputFile-4), looking for the next data input file. 
	 * 
	 * @param propertyBaseName
	 *            the base property name that holds the test file name (e.g.
	 *            dataInputFile)
	 * @throws JSONException 
	 * @returns a string that contains the file name or null if no file is found
	 */
	public String getNextInputFileName(JSONObject binConfig, String propertyBaseName) throws JSONException {
		Logger.detailsFine("DataFile.getNextTestFileName(" + propertyBaseName + ")");
		
		String inputName = null;
		String suffix = null;

		// 	Look for the next file name to run in each path associated with
		// 	propertyName, propertyBaseName-1, propertyBaseName-2, ... propertyBaseName-99 
		//	in the properties file. This loop will pick up where it left 
		//	off last time, using the global variable testNumber.

		while (inputNumber < NUMBER_OF_POSSIBLE_INPUT_FILES && inputName == null) {
			suffix = (inputNumber == 0) ? "" : "-" + inputNumber;

			inputName = binConfig.getString(propertyBaseName + suffix);
			
			if ("".equals(inputName)) {
				inputName = null;
			}

			inputNumber++;

		}

		if(inputName != null )
			return inputName.trim();
		
		Logger.detailsFine("TestDriver.getNextInputFileName(): Returning input name - " + inputName);
		Logger.detailsFine("TestDriver.getNextInputFileName(" + propertyBaseName + ") - done");
		return inputName;
	}
	
}
